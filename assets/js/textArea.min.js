"use strict";
define("textArea", ["core", "lodash", "textCommon", "santaProps"], function(t, e, i, n) {
    var a = t.compMixins,
        s = function(t, e) {
            switch (t) {
                case "left":
                    return {
                        paddingLeft: e,
                        paddingRight: 10
                    };
                case "right":
                    return {
                        paddingLeft: 10,
                        paddingRight: e
                    };
                case "center":
                    return {
                        paddingRight: e,
                        paddingLeft: e
                    }
            }
        },
        o = function(e) {
            return t.compMixins.validatableMixin.getPublicState(e)
        };
    return {
        displayName: "TextArea",
        mixins: [a.skinBasedComp, a.runTimeCompData, i.textScaleMixin, t.compMixins.inputFocusMixin, t.compMixins.validatableMixin.validatable, t.compMixins.compStateMixin(o)],
        propTypes: {
            compData: n.Types.Component.compData,
            compProp: n.Types.Component.compProp,
            shouldResetComponent: n.Types.RenderFlags.shouldResetComponent
        },
        statics: {
            useSantaTypes: !0,
            behaviors: e.assign({}, t.compMixins.inputFocusMixin.INPUT_FOCUS_BEHAVIORS, t.compMixins.validatableMixin.VALIDATABLE_BEHAVIORS)
        },
        focus: function() {
            this.refs.textarea.focus()
        },
        blur: function() {
            this.refs.textarea.blur()
        },
        setCustomValidity: function(t) {
            this.refs.textarea.setCustomValidity(t)
        },
        getInitialState: function() {
            return e.assign(this.getCssState(this.props), o(), {
                value: this.props.compData.value
            })
        },
        getCssState: function(t) {
            return {
                $validation: t.compProp.message ? "invalid" : "valid",
                $label: t.compProp.label ? "hasLabel" : "noLabel"
            }
        },
        componentWillReceiveProps: function(t) {
            t.shouldResetComponent && t.shouldResetComponent !== this.props.shouldResetComponent && this.hideValidityIndication();
            var i = this.getCssState(t);
            e.has(t.compData, "value") && t.compData.value !== this.state.value && (i.value = t.compData.value), this.setState(i)
        },
        onClick: function(t) {
            this.props.compProp.isPreset && t.target.select()
        },
        onKeyDown: function(t) {
            t.stopPropagation()
        },
        onKeyUp: function(t) {
            this.handleAction("keyPress", t)
        },
        onChange: function(t) {
            var e = t.target.value;
            e !== this.state.value && this.setState({
                value: e
            }, function() {
                this.updateData({
                    value: e
                }), this.handleAction("change", t)
            }.bind(this))
        },
        onFocus: function(t) {
            this.handleAction("focus", t)
        },
        onBlur: function(t) {
            this.handleAction("blur", t), this.showValidityIndication()
        },
        getSkinProperties: function() {
            var t = this.props.compProp,
                i = this.props.compData,
                n = {
                    style: {
                        display: "none"
                    }
                },
                a = {
                    "with-validation-indication": this.shouldShowValidityIndication()
                };
            a[this.props.compProp.textAlignment + "-direction"] = !0;
            var o = {
                "": {
                    className: this.classSet(a),
                    disabled: t.isDisabled,
                    "data-disabled": t.isDisabled
                },
                label: t.label ? {
                    children: t.label
                } : n,
                textarea: {
                    value: this.state.value,
                    maxLength: i.maxLength,
                    placeholder: t.placeholder,
                    onChange: t.onChange || this.onChange,
                    onClick: this.onClick,
                    onKeyDown: this.onKeyDown,
                    onKeyUp: this.onKeyUp,
                    onFocus: this.onFocus,
                    onBlur: t.onBlur || this.onBlur,
                    disabled: t.isDisabled,
                    required: t.required,
                    readOnly: t.readOnly,
                    tabIndex: t.tabIndex
                },
                errorMessage: t.message ? function() {
                    return {
                        children: t.message,
                        style: {
                            whiteSpace: "normal"
                        }
                    }
                }() : n
            };
            return o.textarea = e.merge({
                style: e.merge(this.getFontSize(), s(t.textAlignment, t.textPadding))
            }, o.textarea, {
                "data-preview": e.isFunction(this.getComponentPreviewState) && this.getComponentPreviewState()
            }), o
        }
    }
});
//# sourceMappingURL=textArea.min.js.map
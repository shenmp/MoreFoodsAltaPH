"use strict";
define("compUtils/core/compFactory", ["react", "lodash", "loggingUtils", "utils"], function(e, t, n, i) {
    function r(i) {
        var r = p[i];
        if (!r) {
            var h = t.get(o, [i, "def"]);
            if (!h) return void n.log.error("Component not implemented: [" + i + "]");
            var u = e.createClass({
                mixins: a[i].concat([h])
            });
            if (c[i] = u, r = e.createFactory(u), d[i] = r, t.get(o, [i, "isAPIComp"])) {
                var m = s(i, u);
                p[i] = e.createFactory(m)
            } else p[i] = r
        }
    }
    var s, o = {},
        a = {},
        p = {},
        d = {},
        c = {};
    return i.sessionFreezer.freeze(o), i.sessionFreezer.freeze(a), i.sessionFreezer.freeze(p), i.sessionFreezer.freeze(d), i.sessionFreezer.freeze(c), {
        getCompClass: function(e, t) {
            return r(e), t ? d[e] : p[e]
        },
        getCompReactClass: function(e) {
            return this.getCompClass(e), c[e]
        },
        invalidate: function(e) {
            delete p[e]
        },
        extend: function(e, i) {
            o.hasOwnProperty(e) ? a[e] = t.union(a[e].concat(i)) : n.log.error("Trying to extend component [" + e + "] but the component is not defined")
        },
        register: function(e, t, n) {
            return o[e] = {
                def: t,
                isAPIComp: n
            }, a[e] = [], this
        },
        registerMobxObserver: function(e) {
            return s = e, this
        },
        keys: function() {
            return t.keys(o)
        }
    }
}), define("compUtils/core/mobxObserverWrapper", ["lodash", "react", "mobx-react", "utils", "coreUtils", "compUtils/core/compFactory", "santaProps"], function(e, t, n, i, r, s, o) {
    function a(e, t) {
        var n = e.getRootIdsWhichShouldBeRendered();
        return i.componentUtils.shouldBeRendered(n, t)
    }

    function p(e, t, n, i) {
        h(e, t, n, i)
    }

    function d(e, t, n) {
        h(e, [], t, n)
    }

    function c(e) {
        return e && (e.children || e.components)
    }

    function h(e, t, n, i) {
        if (i && t.length > 0) {
            var r = e.getSiteAspect("actionsAspect"),
                s = e.getSiteAspect("behaviorsAspect");
            r.registerBehaviors(i, n, t), s.setBehaviorsForActions(s.convertBehaviors(t, i), n, i)
        }
    }

    function u(e, t) {
        e.registerReLayoutPending(t)
    }

    function m(e) {
        e.reLayoutIfPending && this.callAfterRenderDone(e.reLayoutIfPending)
    }

    function l(t, n) {
        var r = e.get(t, ["mobxObserverWrapperProps", "activeModes", n.rootId]),
            s = e.get(n, ["mobxObserverWrapperProps", "activeModes", n.rootId]);
        return i.modes.getModeChanges(r, s)
    }

    function g(t, n, i, r) {
        var s = {};
        if (t.id === n) s.visibility = "hidden", P(t.type) && (s.width = i.getSiteWidth(), a(r, n) || (s.display = "none"));
        else {
            var o = i.isPageLandingPage(i.getPrimaryPageId()) && "masterPage" === n,
                p = e.includes(N, t.componentType);
            o && (p ? r.isExperimentOpen("sv_partialReLayout") && (s = {
                top: 0
            }) : s = {
                display: "none"
            })
        }
        return s
    }

    function f(t) {
        var n = t ? t.get() : null;
        return e.omitBy(n, function(t, n) {
            return e.isNil(t) || e.isUndefined(t) || "compBehaviors" === n && e.isEmpty(t)
        })
    }

    function v(e) {
        return "SITE_PAGES" === e
    }

    function P(t) {
        return e.includes(["Page", "Document"], t)
    }

    function y(t, n, i) {
        i[n.id] && e.get(n, "layout.docked") && (t.dimentions = i[n.id], t.style.width && (t.style.width = i[n.id].width), t.style.height && (t.style.height = i[n.id].height))
    }

    function C(t, n, i) {
        var r = t.mobxObserverWrapperProps.siteAPI,
            s = r.getSiteData(),
            o = t.mobxObserverWrapperProps.viewerPrivateServices,
            p = k.getCompProps(t.structure, r, t.rootId, o);
        if (p.pageStub = P(t.structure.type) && !a(r, t.rootId), e.get(t, "mobxObserverWrapperProps.dimensionsMap") && y(p, t.structure, t.mobxObserverWrapperProps.dimensionsMap), t.mobxObserverWrapperProps.applyStyleOverrides) {
            var d = g(t.structure, t.rootId, s, r);
            p.style = e.merge(p.style || {}, d)
        }
        return v(t.structure.id) && e.assign(p, t.mobxObserverWrapperProps.propsForSitePages), p.isAffectedByModeChanges = n, i && (p.className = (p.className || "") + " transitioning-comp"), p
    }

    function A(e, t) {
        return "SantaTypeObserver(" + (e.displayName || e.name || t.split(".").pop()) + ")"
    }

    function b(e) {
        return e && s.getCompClass(e) || t.DOM.div
    }

    function I(t, n, i, r, s, o, a, p) {
        var d = s && S(t, r),
            c = n || d,
            h = c && !!a,
            u = C(o, c, p === z.TRANSITION || h),
            m = O(t, i, u.pageStub);
        return u.childrenSet = e.zipObject(e.map(m, "id"), m), u
    }

    function T(t, n) {
        var r;
        return !!e.includes(B, n.componentType) || (r = i.dataUtils.getChildrenData(n, t), e.some(r, T.bind(null, t)))
    }

    function O(t, n, r) {
        var s = i.dataUtils.getChildrenData(t, n);
        return r && (s = e.filter(s, T.bind(null, n))), s
    }

    function x(t) {
        return !e.isEmpty(t)
    }

    function F(t, n, i, r) {
        var s = c(n),
            o = e.map(s, function(e) {
                var n = r && S(e, i);
                return t || n
            });
        return e.zipObject(e.map(s, "id"), o)
    }

    function R(t, n, i) {
        var r = {},
            s = t.childrenSet || [],
            o = n.childrenSet;
        return e.forEach(o, function(e, t) {
            !!s[t] || (r[t] = z.ENTER)
        }), e.forEach(s, function(e, t) {
            !!o[t] ? i[t] && (r[t] = z.TRANSITION) : r[t] = z.LEAVE
        }), r
    }

    function S(t, n) {
        var i = [],
            r = e.get(t, "modes.definitions");
        if (r && r.length) {
            var s = e.map(r, "modeId"),
                o = e.keys(n);
            i = e.intersection(o, s)
        }
        return !e.isEmpty(i)
    }

    function E(t, n, i, r, s) {
        if (!r) return {};
        var o = t.getSiteAspect("windowScrollEvent").getScrollPosition(),
            a = e.partial(e.isEqual, z.TRANSITION);
        return e(i).pickBy(a).mapValues(function(t, i) {
            var a = r.shownInFixed[i] ? r.absoluteLeft[i] - o.x : r.absoluteLeft[i] - s.getSiteX() - o.x;
            return {
                width: r.width[i],
                height: r.height[i],
                left: a,
                top: r.absoluteTop[i] - o.y,
                rotation: e.get(e.find(c(n.structure), {
                    id: i
                }), "layout.rotationInDegrees")
            }
        }).value()
    }

    function M(e, t, n, i, r, s) {
        t.getSiteAspect("actionsAspect").executeAction("modeChange", L.MODE_CHANGED_INIT, {
            modeChanges: n,
            componentAnimations: i,
            transitioningComponentsPrevLayout: r,
            pageId: e,
            onComplete: s
        })
    }

    function W(t, n) {
        return e.filter(t, function(e) {
            return n[e.id]
        })
    }

    function w(t, n, i, r) {
        var s = t.childrenSet,
            o = n.childrenSet,
            a = W(i, r);
        return a = e.zipObject(e.map(a, "id"), a), e.assign(s, a, o)
    }

    function D(t, n, i, r) {
        return e.values(w(t, n, i, r))
    }

    function U(e) {
        e.getSiteAspect("actionsAspect").executeAction("modeChange", L.MODE_CHANGED_EXECUTE)
    }
    var N = ["wysiwyg.viewer.components.PageGroup", "wysiwyg.viewer.components.PagesContainer"],
        L = i.triggerTypesConsts,
        k = o.componentPropsBuilder,
        B = ["wysiwyg.viewer.components.tpapps.TPAGluedWidget", "wysiwyg.viewer.components.tpapps.TPASection", "wysiwyg.viewer.components.tpapps.TPAMultiSection", "wysiwyg.viewer.components.tpapps.TPAWidget"],
        z = {
            ENTER: i.siteConstants.Animations.Modes.AnimationType.ENTER,
            LEAVE: i.siteConstants.Animations.Modes.AnimationType.LEAVE,
            TRANSITION: i.siteConstants.Animations.Modes.AnimationType.TRANSITION
        };
    return function(i, s) {
        return n.observer(t.createClass({
            displayName: A(s, i),
            mixins: [r.renderDoneMixin],
            propTypes: {
                structure: t.PropTypes.object,
                rootId: t.PropTypes.string,
                key: t.PropTypes.string,
                ref: t.PropTypes.string,
                mobxObserverWrapperProps: t.PropTypes.object,
                applyStyleOverrides: t.PropTypes.bool
            },
            componentWillMount: function() {
                this.transitioningChildrenPrevLayout = {}, this.currentlyAnimatingChildren = {}, this.childrenAnimations = {}, this.prevCompProps = {}, this.renderedCompProps = {}, this.childrenToRender = {}, this.isTrackingComputedProps = !1, this.descendantsFinishedAnimationCount = 0, this.modeChangesInPage = {}, this.componentIsActiveModeRoot = !1
            },
            componentWillUpdate: function(e) {
                var t = l(this.props, e);
                this.modeChangesInPage = t
            },
            componentWillUnmount: function() {
                var e = this.props.mobxObserverWrapperProps.siteAPI;
                d(e, this.renderedCompProps.rootId, this.renderedCompProps.structure.id), e.cancelReLayoutPending(this.renderedCompProps.structure.id)
            },
            componentDidMount: function() {
                m.call(this, this.props.mobxObserverWrapperProps.siteAPI), this.renderedCompProps.isAffectedByModeChanges && e.isEmpty(this.childrenToRender) && this.reportAnimationDone()
            },
            componentDidUpdate: function() {
                var t = this.props.mobxObserverWrapperProps.siteAPI;
                x(this.childrenAnimations) ? (M(this.props.rootId, t, this.modeChangesInPage, this.childrenAnimations, this.transitioningChildrenPrevLayout, this.handleModeChangeAnimationsFinished), U(t), this.childrenAnimations = {}, this.transitioningChildrenPrevLayout = {}) : this.renderedCompProps.isAffectedByModeChanges && e.isEmpty(this.childrenToRender) && this.reportAnimationDone(), m.call(this, t)
            },
            assignComputedProps: function(t) {
                var n = f(t.computedProps);
                this.isTrackingComputedProps = !!t.computedProps;
                var i = e.omit(t, ["computedProps", "getObservableUpdateIndex", "getLastFullRenderUpdateIndex"]);
                return n && t.getObservableUpdateIndex && t.getLastFullRenderUpdateIndex && t.getObservableUpdateIndex() >= t.getLastFullRenderUpdateIndex() && e.assign(i, n), i
            },
            updateRenderedCompPropsMap: function(t) {
                var n = this.prevCompProps,
                    i = t.mobxObserverWrapperProps.siteAPI,
                    r = this.currentlyAnimatingChildren,
                    s = !e.isEmpty(this.modeChangesInPage),
                    o = I(t.structure, t.mobxObserverWrapperProps.anyChangeInParentActiveModes, i.getSiteData().isMobileView(), this.modeChangesInPage, s, t, n, t.mobxObserverWrapperProps.compAnimationType);
                if (o = this.assignComputedProps(o), s) {
                    this.componentIsActiveModeRoot = S(t.structure, this.modeChangesInPage);
                    var a = F(o.isAffectedByModeChanges, t.structure, this.modeChangesInPage, s);
                    this.childrenAnimations = R(n, o, a), this.transitioningChildrenPrevLayout = E(i, n, this.childrenAnimations, t.mobxObserverWrapperProps.measureMap, i.getSiteData()), e.assign(r, this.childrenAnimations), this.descendantsFinishedAnimationCount = e.keys(this.childrenAnimations).length, e.isEmpty(this.childrenAnimations) || M(t.rootId, i, this.modeChangesInPage, this.childrenAnimations, this.transitioningChildrenPrevLayout, this.handleModeChangeAnimationsFinished)
                }
                x(r) ? this.childrenToRender = D(n, o, this.childrenToRender, r) : this.childrenToRender = e.values(o.childrenSet), this.renderedCompProps = o, this.prevCompProps = o
            },
            compRefFunction: function(e) {
                this.addRefFunction && this.addRefFunction(e)
            },
            reportAnimationDone: function() {
                this.props.mobxObserverWrapperProps.descendantsFinishedAnimationCallback && this.props.mobxObserverWrapperProps.descendantsFinishedAnimationCallback(), this.componentIsActiveModeRoot && (this.componentIsActiveModeRoot = !1, this.forceUpdate())
            },
            allDescendantsAnimationsFinished: function() {
                return 0 === this.descendantsFinishedAnimationCount
            },
            descendantsFinishedAnimationCallback: function() {
                this.descendantsFinishedAnimationCount--, !x(this.currentlyAnimatingChildren) && this.allDescendantsAnimationsFinished() && this.reportAnimationDone()
            },
            getChildProps: function(t) {
                var n = e.assign({}, this.props.mobxObserverWrapperProps, {
                    anyChangeInParentActiveModes: this.renderedCompProps.isAffectedByModeChanges,
                    compAnimationType: this.childrenAnimations[t.id],
                    descendantsFinishedAnimationCallback: this.descendantsFinishedAnimationCallback
                });
                return {
                    structure: t,
                    rootId: this.props.rootId,
                    mobxObserverWrapperProps: n,
                    key: t.id,
                    refInParent: t.id,
                    pageStub: this.props.pageStub || this.renderedCompProps.pageStub
                }
            },
            getCompFinalProps: function() {
                this.addRefFunction = this.props.mobxObserverWrapperProps.addComponentRef, this.addRefFunction && (this.addRefFunction = e.partialRight(this.addRefFunction, this.props.structure.id)), this.renderedCompProps.ref = this.compRefFunction;
                var t = e.assign({}, this.renderedCompProps, this.props);
                return delete t.mobxObserverWrapperProps, t
            },
            render: function() {
                this.updateRenderedCompPropsMap(this.props), p(this.props.mobxObserverWrapperProps.siteAPI, this.renderedCompProps.compBehaviors, this.renderedCompProps.rootId, this.renderedCompProps.structure.id), this.isTrackingComputedProps && u(this.props.mobxObserverWrapperProps.siteAPI, this.renderedCompProps.structure.id);
                var n = e.map(this.childrenToRender, function(e) {
                        return b(e.componentType)(this.getChildProps(e))
                    }.bind(this)),
                    i = this.getCompFinalProps();
                return t.createElement(s, i, n)
            },
            handleModeChangeAnimationsFinished: function(t) {
                this.currentlyAnimatingChildren = e.omit(this.currentlyAnimatingChildren, e.keys(t)), !x(this.currentlyAnimatingChildren) && this.allDescendantsAnimationsFinished() && this.reportAnimationDone()
            }
        }))
    }
}), define("compUtils", ["compUtils/core/compFactory", "compUtils/core/mobxObserverWrapper"], function(e, t) {
    return {
        compFactory: e,
        mobxObserverWrapper: t
    }
});
//# sourceMappingURL=compUtils.min.js.map
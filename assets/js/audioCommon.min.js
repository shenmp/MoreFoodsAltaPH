"use strict";
define("audioCommon/mixins/audioMixin", ["lodash", "utils", "santaProps"], function(i, o, t) {
    var e = t.Types;
    return {
        propTypes: {
            isPlaying: e.Audio.isPlaying,
            isSoundManagerOnResetup: e.Audio.isSoundManagerOnResetup,
            soundManagerReady: e.Audio.soundManagerReady,
            createAudioObj: e.Audio.createAudioObj,
            updatePlayingComp: e.Audio.updatePlayingComp,
            updatePausingComp: e.Audio.updatePausingComp,
            onHTML5ErrorTryToReloadWithFlash: e.Audio.onHTML5ErrorTryToReloadWithFlash,
            isPlayingAllowed: e.RenderFlags.isPlayingAllowed,
            compData: e.Component.compData.isRequired,
            id: e.Component.id.isRequired,
            serviceTopology: e.ServiceTopology.serviceTopology,
            isMobileView: e.isMobileView
        },
        getInitialState: function() {
            return this.audioObj = null, this.isAudioPlaying = !1, this.trackPosition = 0, this.isPlayingAllowed = this.props.isPlayingAllowed, null
        },
        componentWillReceiveProps: function(i) {
            this.props.compData.uri !== i.compData.uri && this.clearAudioObject(), i.isPlaying ? this.setState({
                $playerState: "playing"
            }) : this.props.isPlaying && this.setState({
                $playerState: "pausing"
            })
        },
        componentDidUpdate: function() {
            "mobile" !== this.getDeviceState() && this.props.isPlayingAllowed ? this.props.isPlayingAllowed !== this.isPlayingAllowed && (this.isPlayingAllowed = this.props.isPlayingAllowed, this.autoPlay && this.initiatePlay()) : (this.isPlayingAllowed = this.props.isPlayingAllowed, !this.isPlayingAllowed && this.props.isPlaying && this.initiatePause())
        },
        componentDidMount: function() {
            "mobile" !== this.getDeviceState() && this.autoPlay && this.isPlayingAllowed && this.initiatePlay()
        },
        componentWillUnmount: function() {
            this.isAudioPlaying && "playing" === this.state.$playerState && this.initiatePause(), this.clearAudioObject()
        },
        getOrCreateAudioObject: function() {
            return this.audioObj || this.createAudioObject()
        },
        createAudioObject: function() {
            var i = this;
            if (!i.props.compData.uri) return !1;
            var o = {
                id: i.props.id,
                url: i.props.serviceTopology.staticAudioUrl + "/" + i.props.compData.uri,
                autoPlay: !1,
                stream: !0,
                multiShot: !0,
                multiShotEvents: !0,
                autoLoad: !i.props.isMobileView || !i.props.isPlayingAllowed,
                usePolicyFile: !1,
                whileloading: function() {
                    "function" == typeof i.whileLoadingHandler && i.whileLoadingHandler(this.duration)
                },
                onfailure: function() {
                    i.failedToLoadAudioFile()
                },
                onfinish: function() {
                    i.finishedPlayingAudio(this.id)
                },
                onsuspend: function() {
                    i.audioLoadingSuspended(this.id)
                },
                onload: function(o) {
                    o || i.props.onHTML5ErrorTryToReloadWithFlash()
                }
            };
            return i.props.createAudioObj(o)
        },
        clearAudioObject: function() {
            this.audioObj && (i.isFunction(this.audioObj.pause) && this.audioObj.pause(), this.audioObj = null, this.trackPosition = 0, this.resetTrackPosition && this.resetTrackPosition())
        },
        failedToLoadAudioFile: function(i) {
            var t = "Failed to load audio file " + i;
            o.log.verbose("%c" + t, "color: #ff9494; font-size: 24px;"), o.log.error(t)
        },
        audioLoadingSuspended: function(i) {
            var t = "Browser has chosen to stop downloading audio file " + i;
            o.log.verbose("%c" + t, "color: #ff9494; font-size: 24px;")
        },
        playAudio: function() {
            var i = this,
                o = {
                    volume: i.audioVolume,
                    position: i.trackPosition,
                    whileplaying: function() {
                        i.trackPosition = this.position, "function" == typeof i.whilePlayingHandler && i.whilePlayingHandler(this.position)
                    }
                };
            this.setVolume(this.audioVolume), this.audioObj.play(o)
        },
        updateAudioObject: function() {
            this.audioObj = this.getOrCreateAudioObject(), this.props.isSoundManagerOnResetup && (this.audioObj = null), this.audioObj && (this.isAudioPlaying || "playing" !== this.state.$playerState ? this.isAudioPlaying && "pausing" === this.state.$playerState ? (this.isAudioPlaying = !1, this.audioObj.pause()) : "repeat" === this.state.$playerState && (this.isAudioPlaying = !1) : (this.isAudioPlaying = !0, this.playAudio()))
        },
        getDeviceState: function() {
            return this.props.isMobileView ? "mobile" : "desktop"
        },
        initiatePlay: function() {
            i.isEmpty(this.props.compData.uri) || "" === this.props.compData.uri || this.props.updatePlayingComp(this)
        },
        initiatePause: function() {
            this.props.updatePausingComp()
        },
        getAudioDuration: function() {
            return this.audioObj.duration
        },
        seekAudio: function(i) {
            this.trackPosition = i, this.isAudioPlaying ? this.audioObj.setPosition(i) : this.initiatePlay()
        },
        setVolume: function(i) {
            this.audioVolume = i, this.isAudioPlaying && this.audioObj.setVolume(i)
        },
        muteAudio: function() {
            this.audioObj.mute()
        },
        unmuteAudio: function() {
            this.audioObj.unmute()
        }
    }
}), define("audioCommon", ["audioCommon/mixins/audioMixin"], function(i) {
    return {
        audioMixin: i
    }
});
//# sourceMappingURL=audioCommon.min.js.map
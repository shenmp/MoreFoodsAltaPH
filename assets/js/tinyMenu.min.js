"use strict";
define("tinyMenu/components/tinyMenuItem", ["lodash", "react", "reactDOM", "utils"], function(e, t, n, i) {
    function s() {
        return e.get(this, ["link", "pageId", "id"])
    }

    function r(t) {
        var n = (t = t || this.props).options.currentPage;
        return {
            isSubMenuOpen: e.some(t.menuItem.items, function(e) {
                return s.call(e) === n
            })
        }
    }

    function o(n, i) {
        function r(e) {
            return e.isCurrentPage
        }

        function o(e) {
            return e.isCurrentAnchor
        }
        var a = e.chain(n).filter("isVisibleMobile").map(function(t) {
            var n = e.get(t, ["link", "type"]),
                r = {
                    item: t
                };
            return r.isCurrentPage = "PageLink" === n && s.call(t) === i.currentPage, r.isCurrentAnchor = i.currentAnchor && "AnchorLink" === n && e.get(t, ["link", "anchorDataId", "id"]) === i.currentAnchor, r
        }).reduce(function(t, n) {
            if (i.currentAnchor)
                if (n.isCurrentAnchor) {
                    var s = e.find(t, r);
                    s && (s.isCurrentPage = !1)
                } else n.isCurrentPage && e.find(t, o) && (n.isCurrentPage = !1);
            return t.push(n), t
        }, []).map(function(e) {
            return t.createElement(c, {
                menuItem: e.item,
                current: e.isCurrentPage || e.isCurrentAnchor,
                options: i,
                key: "item" + e.item.id
            })
        }).value();
        if (i.useSeparators) {
            for (var u = [], l = 0; l < a.length; ++l) u.push(a[l]), l < a.length - 1 && u.push(t.DOM.div({
                className: i.styleId + "_separator",
                key: "separator_" + l
            }));
            a = u
        }
        return a
    }
    var a = i.cssUtils,
        c = t.createClass({
            displayName: "TinyMenuItem",
            propTypes: {
                menuItem: t.PropTypes.object,
                options: t.PropTypes.object,
                current: t.PropTypes.bool
            },
            statics: {
                buildChildren: o
            },
            getInitialState: r,
            onSubMenuToggle: function(e) {
                this.onSubMenuClick(e), e.stopPropagation()
            },
            onSubMenuClick: function(t) {
                var i = !this.state.isSubMenuOpen;
                this.setState({
                    isSubMenuOpen: i
                }, function() {
                    if (i) {
                        var t = n.findDOMNode(this);
                        e.isFunction(t.scrollIntoView) && t.scrollIntoView()
                    }
                }), this.props.menuItem.link || t.stopPropagation()
            },
            componentWillReceiveProps: function(e) {
                this.props.options.timestamp !== e.options.timestamp && this.setState(r(e))
            },
            render: function() {
                function n(e) {
                    return a.concatenateStyleIdToClassName(u.styleId, e)
                }
                var i = this.props.menuItem,
                    s = e.some(i.items, "isVisibleMobile"),
                    r = s ? this.onSubMenuClick : this.props.options.clickCallback,
                    c = i.id,
                    u = this.props.options,
                    l = t.DOM.a(e.merge({
                        children: i.label,
                        className: a.concatenateStyleIdToClassList(u.styleId, ["link", this.props.current && "current"]),
                        onClick: r,
                        key: "link" + c
                    }, e.get(i, ["link", "render"])));
                if (!s) return t.DOM.li({
                    className: n("item")
                }, l);
                var p = t.DOM.span({
                        className: a.concatenateStyleIdToClassList(u.styleId, ["toggler", this.props.current && "current"]),
                        key: "toggler" + c,
                        onClick: this.onSubMenuToggle
                    }),
                    h = t.DOM.ul({
                        ref: "subMenuContainer",
                        className: n("submenu")
                    }, o(i.items, e.defaults({
                        useSeparators: !1
                    }, u))),
                    m = [l, p];
                return t.DOM.li({
                    key: "item" + this.props.menuItem.id,
                    children: (u.useSeparators ? [t.DOM.div({
                        className: n("header"),
                        key: "header" + c
                    }, m)] : m).concat([h]),
                    className: a.concatenateStyleIdToClassList(u.styleId, ["item", "has-children", this.state.isSubMenuOpen && "open"])
                })
            }
        });
    return c
}), define("tinyMenu", ["react", "lodash", "core", "tinyMenu/components/tinyMenuItem", "reactDOM", "santaProps"], function(e, t, n, i, s, r) {
    return {
        displayName: "TinyMenu",
        mixins: [n.compMixins.skinBasedComp],
        propTypes: {
            linkRenderInfo: r.Types.Link.linkRenderInfo,
            rootNavigationInfo: r.Types.Component.rootNavigationInfo,
            id: r.Types.Component.id,
            key: r.Types.Component.key,
            style: r.Types.Component.style,
            styleId: r.Types.Component.styleId,
            skin: r.Types.Component.skin,
            currentUrlPageId: r.Types.Component.currentUrlPageId,
            siteWidth: r.Types.siteWidth,
            browserFlags: r.Types.Browser.browserFlags,
            anchorChangeEvent: r.Types.SiteAspects.anchorChangeEvent,
            windowResizeEvent: r.Types.SiteAspects.windowResizeEvent,
            siteScrollingBlocker: r.Types.SiteAspects.siteScrollingBlocker,
            isTinyMenuOpenAllowed: r.Types.RenderFlags.isTinyMenuOpenAllowed,
            siteMenuWithRender: r.Types.Menu.siteMenuWithRender,
            activeAnchorId: r.Types.AnchorChange.activeAnchorId
        },
        statics: {
            useSantaTypes: !0
        },
        isForcedOpen: function() {
            return t.isFunction(this.getComponentPreviewState) && "open" === this.getComponentPreviewState()
        },
        getMenuState: function() {
            return this.isForcedOpen() ? "menuOpen" : this.state.menuState
        },
        isMenuOpen: function() {
            return "menuOpen" === this.getMenuState()
        },
        getInitialState: function() {
            return {
                menuState: "menuInitial",
                timestamp: new Date
            }
        },
        onOrientationChange: function() {
            this.registerReLayout(), this.closeMenu()
        },
        onAnchorChange: function(e) {
            var t = e.activeAnchorComp.id;
            t !== this.state.currentAnchor && this.setState({
                currentAnchor: t
            })
        },
        onMouseClick: function() {
            this.isMenuOpen() ? this.closeMenu() : this.showMenu()
        },
        onMenuButtonClick: function(e) {
            this.onMouseClick(), e.stopPropagation(), e.preventDefault()
        },
        onMenuStateChange: function() {
            this.registerReLayout(), this.forceUpdate()
        },
        closeMenu: function() {
            this.timestamp = new Date, this.isMenuOpen() && this.setState({
                menuState: "menuClosed"
            }, function() {
                this.onMenuStateChange()
            }.bind(this))
        },
        showMenu: function() {
            this.isEmpty || this.setState({
                menuState: "menuOpen"
            }, this.onMenuStateChange)
        },
        updateProps: function(e) {
            if (this.items = e.siteMenuWithRender, this.isEmpty = t.every(this.items, {
                    isVisibleMobile: !1
                }), this.isClassicSkin()) {
                var n = t.get(this.props, ["compProp", "metaData", "schemaVersion"]);
                this.preserveLegacySize = !n || "1.0" === n
            }
            this.siteWidth = e.siteWidth, this.forceMenuItemsScroll = e.browserFlags.forceOverflowScroll, this.animateSVG = e.browserFlags.animateTinyMenuIcon
        },
        componentWillMount: function() {
            this.props.windowResizeEvent.registerToOrientationChange(this), this.props.anchorChangeEvent.registerToAnchorChange(this), this.updateProps(this.props)
        },
        isFixed: function() {
            return "fixed" === this.props.style.position
        },
        isClassicSkin: function() {
            return "wysiwyg.viewer.skins.mobile.TinyMenuSkin" === this.props.skin
        },
        componentWillReceiveProps: function(e) {
            (this.props.currentUrlPageId !== e.currentUrlPageId || this.isMenuOpen() && !e.isTinyMenuOpenAllowed) && this.closeMenu(), this.updateProps(e)
        },
        componentDidUpdate: function() {
            this.isMenuOpen() && (s.findDOMNode(this.refs.menuContainer).scrollTop = 0), this.isClassicSkin() && !this.isFixed() || this.props.siteScrollingBlocker.setSiteScrollingBlocked(this, this.isMenuOpen())
        },
        componentDidMount: function() {
            this.props.siteScrollingBlocker.registerScrollingLayer(this.refs.menuContainer)
        },
        getRootStyle: function() {
            return this.getRootPosition ? {
                position: this.getRootPosition(this.props.style)
            } : {}
        },
        getDirection: function() {
            var e = t.get(this, ["props", "compProp", "direction"], "left");
            return this.getStyleProperty("textAlignment", e)
        },
        getSkinProperties: function() {
            var n = this.isMenuOpen(),
                s = this.props.styleId,
                r = this.isClassicSkin(),
                o = this.isFixed(),
                a = {},
                c = {
                    styleId: s,
                    currentPage: this.props.currentUrlPageId,
                    clickCallback: this.onMouseClick,
                    currentAnchor: this.state.currentAnchor,
                    timestamp: this.timestamp,
                    useSeparators: !r
                },
                u = i.buildChildren(this.items, c),
                l = "dir-" + this.getDirection();
            return r && (a["preserve-legacy-size"] = this.preserveLegacySize, o && (this.props.style.zIndex = n ? 1e3 : 1)), a[this.getMenuState()] = !0, a[l] = !0, {
                "": {
                    id: this.props.id,
                    key: this.props.key + "_" + this.props.skin,
                    ref: this.props.id,
                    className: "hidden-on-warmup",
                    style: this.getRootStyle()
                },
                fullScreenOverlay: {
                    ref: this.props.id + "fullScreenOverlay",
                    className: "fullScreenOverlay " + this.classSet(a),
                    style: {
                        top: 0
                    },
                    onClick: this.closeMenu
                },
                fullScreenOverlayContent: {
                    className: "fullScreenOverlayContent",
                    style: {
                        width: this.siteWidth,
                        top: 0
                    }
                },
                menuBackground: {
                    className: this.classSet(a)
                },
                menuButton: {
                    ref: this.props.id + "menuButton",
                    onClick: this.onMenuButtonClick,
                    className: this.classSet(t.assign({
                        "preserve-legacy-size": this.preserveLegacySize,
                        "force-open": this.isForcedOpen(),
                        "no-animation": !this.animateSVG
                    }, a))
                },
                iconSVG: {
                    preserveAspectRatio: n ? "" : "none"
                },
                menuContainer: {
                    children: e.DOM.ul({
                        children: u,
                        className: this.classSet({
                            "top-menu": !0,
                            open: n,
                            "force-scroll": this.forceMenuItemsScroll
                        }),
                        ref: "menuItems",
                        id: this.props.id + "menuItems"
                    }),
                    className: this.classSet(a)
                }
            }
        }
    }
});
//# sourceMappingURL=tinyMenu.min.js.map
"use strict";
define("backgroundCommon/mixins/backgroundDetectionMixin", ["lodash", "react", "utils", "imageClientApi", "color", "santaProps"], function(e, t, i, o, a, s) {
    function n(t) {
        return e.get(t.compDesign, "background", e.get(t.compData, "background", {}))
    }

    function r(e, t, a) {
        var s = e && e.uri;
        if (s) {
            var n = {
                    id: s,
                    width: e.width,
                    height: e.height
                },
                r = {
                    width: 1,
                    height: 1
                },
                d = o.getData(o.fittingTypes.SCALE_TO_FILL, n, r).uri,
                y = this.props.getMediaFullStaticUrl(d);
            i.imageUtils.getImageMeanBrightness(y, {
                width: 1,
                height: 1
            }, t, a)
        } else {
            var l = p.call(this);
            t(l.values.hsv[2], l.values.alpha)
        }
    }

    function p() {
        var e = n(this.props);
        return new a(i.colorParser.getColor(this.props.colorsMap, e.color, e.colorOpacity))
    }

    function d(e, t) {
        var i = e && e.uri,
            o = i !== this.lastBackgroundImageUrl,
            a = t && t.hexString(),
            s = this.lastBackgroundBgColor && this.lastBackgroundBgColor.hexString(),
            n = !i && a !== s,
            p = t && t.values.alpha !== this.lastAlpha;
        (o || n || p) && r.call(this, e, function(e, t) {
            this.props.updateColorInfo(this.props.id, {
                brightness: e,
                alpha: t
            })
        }.bind(this)), this.lastBackgroundImageUrl = i, this.lastBackgroundBgColor = t, this.lastAlpha = t.values.alpha
    }
    return {
        propTypes: {
            id: t.PropTypes.string,
            compDesign: t.PropTypes.object,
            compData: t.PropTypes.object,
            colorsMap: s.Types.Theme.colorsMap.isRequired,
            isMobileView: s.Types.isMobileView.isRequired,
            updateColorInfo: s.Types.VerticalAnchorsMenu.updateInformation.isRequired,
            getMediaFullStaticUrl: s.Types.ServiceTopology.getMediaFullStaticUrl.isRequired
        },
        componentDidMount: function() {
            if (!this.props.isMobileView) {
                var e = p.call(this),
                    t = this.getMediaImageData();
                d.call(this, t, e)
            }
        },
        componentDidUpdate: function() {
            if (!this.props.isMobileView) {
                var e = p.call(this),
                    t = e && e.hexString(),
                    i = this.lastBackgroundBgColor && this.lastBackgroundBgColor.hexString(),
                    o = this.getMediaImageData(),
                    a = t !== i,
                    s = (o && o.uri) !== this.lastBackgroundImageUrl,
                    n = e && e.values.alpha !== this.lastAlpha;
                (a || s || n) && d.call(this, o, e)
            }
        },
        getMediaImageData: function() {
            var e = n(this.props).mediaRef;
            if (e) switch (e.type) {
                case "Image":
                    return e;
                case "WixVideo":
                    return e.posterImageRef
            }
            return null
        }
    }
}), define("backgroundCommon/components/bgImage", ["lodash", "react", "core", "utils"], function(e, t, i, o) {
    return {
        displayName: "bgImage",
        mixins: [i.compMixins.skinBasedComp],
        propTypes: {
            compData: t.PropTypes.object.isRequired,
            "data-type": t.PropTypes.string.isRequired
        },
        statics: {
            useSantaTypes: !0
        },
        getSkinProperties: function() {
            var t = {
                    width: "100%"
                },
                i = {
                    position: "absolute",
                    width: "100%"
                };
            e.isNumber(this.props.compData.opacity) && (i.opacity = this.props.compData.opacity);
            var a = {
                "": {
                    style: t
                }
            };
            return a[o.balataConsts.IMAGE] = {
                style: i,
                "data-type": this.props["data-type"]
            }, a
        }
    }
}), define("backgroundCommon/mixins/videoPlayerMixin", ["lodash", "react", "core", "utils", "image", "santaProps"], function(e, t, i, o, a, s) {
    function n(t) {
        return e.includes(["png"], r(t))
    }

    function r(e) {
        return (/[.]([^.]+)$/.exec(e) && /[.]([^.]+)$/.exec(e)[1] || "").toLowerCase()
    }
    var p = o.mediaConsts;
    return {
        mixins: [i.compMixins.skinBasedComp],
        propTypes: e.defaults({
            compData: t.PropTypes.object.isRequired,
            compProp: t.PropTypes.object,
            isPlayingAllowed: t.PropTypes.bool,
            mediaQuality: t.PropTypes.string,
            notifyMediaState: t.PropTypes.func.isRequired,
            setMediaAPI: t.PropTypes.func.isRequired
        }, s.santaTypesUtils.getSantaTypesByDefinition(a)),
        externalAPI: ["play", "pause", "stop", "seek", "setVolume", "mute", "unMute", "setRate", "setSrc"],
        mediaAPI: function(t, i) {
            var o = this[t];
            o && e.includes(this.externalAPI, t) && o.apply(this, i)
        },
        getPosterImageComp: function(t, i, o) {
            var a = {
                display: i ? "none" : void 0
            };
            return n(t.uri) && (a.backgroundColor = "#000000"), this.createChildComponent(t, "core.components.Image", p.balataConsts.POSTER, e.assign({
                ref: p.balataConsts.POSTER,
                id: this.props.id + p.balataConsts.POSTER,
                imageData: t,
                displayMode: this.props.compData.fittingType,
                alignType: this.props.compData.alignType,
                containerWidth: 0,
                containerHeight: 0,
                style: a
            }, o))
        }
    }
}), define("backgroundCommon/components/html5Video", ["lodash", "utils", "backgroundCommon/mixins/videoPlayerMixin"], function(e, t, i) {
    var o = t.mediaConsts;
    return {
        displayName: "html5Video",
        mixins: [i],
        statics: {
            useSantaTypes: !0
        },
        getInitialState: function() {
            return this.playWhenReady = !1, {
                mediaQuality: this.props.mediaQuality,
                showVideo: !1
            }
        },
        componentDidMount: function() {
            this.props.setMediaAPI(this.mediaAPI), this.refs.video.addEventListener("timeupdate", this.handlePosterVisibilityOnce), this.props.notifyMediaState({
                type: o.eventTypes.MOUNT,
                playbackState: o.playbackTypes.LOADING
            }), this.setRate(this.props.compData.playbackSpeed || 1), this.props.compProp.autoplay && this.props.isPlayingAllowed && this.play()
        },
        componentDidUpdate: function() {
            this.setRate(this.props.compData.playbackSpeed || 1)
        },
        componentWillUnmount: function() {
            this.props.setMediaAPI(null), this.refs.video.removeEventListener("timeupdate", this.handlePosterVisibilityOnce), this.removeVideoSecurely()
        },
        handlePosterVisibilityOnce: function() {
            this.refs.video.currentTime > 0 && (this.setState({
                showVideo: !0
            }), this.refs.video.removeEventListener("timeupdate", this.handlePosterVisibilityOnce))
        },
        resetPosterState: function() {
            this.state.showVideo && (this.setState({
                showVideo: !1
            }), this.refs.video.addEventListener("timeupdate", this.handlePosterVisibilityOnce))
        },
        removeVideoSecurely: function() {
            this.refs.video.pause(), e.forEach(this.refs.video.children, function(e) {
                "source" === e.nodeName.toLowerCase() && e.setAttribute("src", "")
            }), this.refs.video.load()
        },
        canVideoPlay: function() {
            return this.refs.video.readyState >= this.refs.video.HAVE_CURRENT_DATA
        },
        play: function() {
            this.canVideoPlay() ? this.refs.video.play() : this.playWhenReady = !0
        },
        pause: function() {
            this.refs.video.pause()
        },
        stop: function() {
            this.pause(), this.seek(0), this.resetPosterState()
        },
        setVolume: function(e) {
            this.refs.video.volume = Math.max(0, Math.min(1, e))
        },
        mute: function() {
            this.refs.video.muted = !0
        },
        unMute: function() {
            this.refs.video.muted = !1
        },
        seek: function(e) {
            this.refs.video.currentTime = Math.max(0, Math.min(e, this.refs.video.duration || this.props.compData.duration))
        },
        setRate: function(e) {
            this.refs.video.playbackRate = Math.max(0, e)
        },
        setSrc: function(e) {
            e !== this.state.mediaQuality && this.setState({
                mediaQuality: e
            })
        },
        onLoadStart: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.LOAD,
                playbackState: o.playbackTypes.READY,
                volume: this.refs.video.volume,
                muted: this.refs.video.muted,
                looped: this.props.compProp.loop,
                currentTime: this.refs.video.currentTime,
                progress: 0
            })
        },
        onDurationChange: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.LOAD,
                duration: parseInt(100 * this.refs.video.duration, 10) / 100
            })
        },
        onLoadedData: function() {
            this.playWhenReady || this.props.notifyMediaState({
                type: o.eventTypes.LOAD,
                playbackState: o.playbackTypes.IDLE
            })
        },
        onCanPlay: function() {
            this.playWhenReady && (this.play(), this.playWhenReady = !1)
        },
        onTimeUpdate: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.TIME_UPDATE,
                currentTime: this.refs.video.currentTime
            })
        },
        onPlayEnded: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.PLAYSTATE,
                playbackState: o.playbackTypes.PLAY_ENDED
            })
        },
        onPlay: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.PLAYSTATE,
                playbackState: o.playbackTypes.PLAYING
            })
        },
        onPause: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.PLAYSTATE,
                playbackState: o.playbackTypes.PAUSED
            })
        },
        onError: function(e) {
            e.currentTarget.networkState === e.currentTarget.NETWORK_NO_SOURCE ? this.props.notifyMediaState({
                type: o.eventTypes.ERROR,
                error: o.errorTypes.NO_VIDEO_FOUND
            }) : this.props.notifyMediaState({
                type: o.eventTypes.ERROR,
                error: o.errorTypes.VIDEO_GENERAL_ERROR
            })
        },
        onStalled: function(e) {
            e.currentTarget.readyState === e.currentTarget.HAVE_NOTHING && this.props.notifyMediaState({
                type: o.eventTypes.ERROR,
                error: o.errorTypes.NO_VIDEO_FOUND
            })
        },
        onProgress: function() {
            var e = this.refs.video.buffered;
            this.props.notifyMediaState({
                type: o.eventTypes.PROGRESS,
                progress: e && e.length ? e.end(e.length - 1) : 0
            })
        },
        onSeekStart: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.PLAYSTATE,
                playbackState: o.playbackTypes.SEEKING
            })
        },
        onSeekEnd: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.PLAYSTATE,
                playbackState: o.playbackTypes.SEEKING_ENDED
            })
        },
        onVolumeChange: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.VOLUME,
                volume: this.refs.video.volume,
                muted: this.refs.video.muted
            })
        },
        onRateChange: function() {
            this.props.notifyMediaState({
                type: o.eventTypes.RATE,
                playbackRate: this.refs.video.playbackRate
            })
        },
        getSkinProperties: function() {
            var e = {
                    width: "100%"
                },
                t = this.getPosterImageComp(this.props.compData.posterImageRef, this.state.showVideo),
                i = {
                    "": {
                        "data-quality": this.state.mediaQuality,
                        style: e
                    },
                    video: {
                        preload: this.props.compData.preload || "none",
                        onEnded: this.onPlayEnded,
                        onError: this.onError,
                        onLoadStart: this.onLoadStart,
                        onLoadedData: this.onLoadedData,
                        onCanPlay: this.onCanPlay,
                        onDurationChange: this.onDurationChange,
                        onPause: this.onPause,
                        onPlay: this.onPlay,
                        onProgress: this.onProgress,
                        onRateChange: this.onRateChange,
                        onSeeked: this.onSeekEnd,
                        onSeeking: this.onSeekStart,
                        onStalled: this.onStalled,
                        onTimeUpdate: this.onTimeUpdate,
                        onVolumeChange: this.onVolumeChange,
                        style: {
                            visibility: this.state.showVideo ? void 0 : "hidden"
                        }
                    },
                    poster: t
                };
            return (this.props.compProp.mute || !1 === this.props.compData.hasAudio) && (i.video.muted = "muted"), i
        }
    }
}), define("backgroundCommon/components/youtubeVideo", ["lodash", "reactDOM", "utils", "backgroundCommon/mixins/videoPlayerMixin"], function(e, t, i, o) {
    var a = i.mediaConsts;
    return {
        displayName: "YoutubeVideo",
        mixins: [o],
        statics: {
            useSantaTypes: !0
        },
        getInitialState: function() {
            return this.ytPlayer = null, this.ytScriptReady = !1, this.setVideoPlayerWhenReady = !1, this.isPlaying = !1, this.timeUpdateTimer = {
                type: "",
                id: null
            }, {
                showVideo: !1
            }
        },
        componentDidMount: function() {
            this.loadYTScript(), this.props.setMediaAPI(this.mediaAPI), this.props.notifyMediaState({
                type: a.eventTypes.MOUNT,
                playbackState: a.playbackTypes.LOADING
            }), this.props.compProp.autoplay && this.props.isPlayingAllowed && this.play()
        },
        componentWillUnmount: function() {
            this.props.setMediaAPI(null), this.stopSimulateTimeUpdate(), this.removeVideoSecurely(), this.props.notifyMediaState({
                type: a.eventTypes.MOUNT,
                playbackState: a.playbackTypes.LOADING
            })
        },
        loadYTScript: function() {
            if ("undefined" == typeof window || e.get(window, "YT")) this.onYoutubeScriptReady();
            else {
                var t = window.document.createElement("script");
                t.src = "https://www.youtube.com/player_api";
                var i = window.document.getElementsByTagName("script")[0];
                i.parentNode.insertBefore(t, i), window.onYouTubeIframeAPIReady = this.onYoutubeScriptReady
            }
        },
        handlePosterVisibilityOnce: function() {
            this.setState({
                showVideo: !0
            })
        },
        resetPosterState: function() {
            this.state.showVideo && this.setState({
                showVideo: !1
            })
        },
        onYoutubeScriptReady: function() {
            this.ytScriptReady = !0, this.setVideoPlayerWhenReady && this.setVideoPlayer()
        },
        startSimulateTimeUpdate: function() {
            this.isPlaying ? this.timeUpdateTimer = {
                type: "requestAnimationFrame",
                id: window.requestAnimationFrame(this.startSimulateTimeUpdate)
            } : window.requestIdleCallback ? this.timeUpdateTimer = {
                type: "requestIdleCallback",
                id: window.requestIdleCallback(this.startSimulateTimeUpdate)
            } : this.timeUpdateTimer = {
                type: "setTimeout",
                id: window.setTimeout(this.startSimulateTimeUpdate, 100)
            }, this.onTimeUpdate(), this.onProgress()
        },
        stopSimulateTimeUpdate: function() {
            switch (this.timeUpdateTimer.type) {
                case "requestAnimationFrame":
                    window.cancelAnimationFrame(this.timeUpdateTimer.id);
                    break;
                case "requestIdleCallback":
                    window.cancelIdleCallback(this.timeUpdateTimer.id);
                    break;
                case "setTimeout":
                    window.clearTimeout(this.timeUpdateTimer.id)
            }
        },
        setVideoPlayer: function() {
            this.ytScriptReady ? this.ytPlayer = new window.YT.Player(this.refs.video, {
                videoId: this.props.compData.videoId,
                width: t.findDOMNode(this).offsetWidth,
                height: t.findDOMNode(this).offsetHeight,
                events: {
                    onReady: this.onPlayerReady,
                    onStateChange: this.onPlayerStateChange,
                    onPlaybackRateChange: this.onRateChange,
                    onError: this.onError
                },
                autoplay: 1,
                loop: this.props.compProp.loop ? 1 : 0,
                rel: 0
            }) : this.setVideoPlayerWhenReady = !0
        },
        removeVideoSecurely: function() {
            this.ytPlayer && this.ytPlayer.destroy()
        },
        play: function() {
            this.ytPlayer ? this.ytPlayer.playVideo && this.ytPlayer.playVideo() : this.setVideoPlayer()
        },
        pause: function() {
            this.ytPlayer && this.ytPlayer.pauseVideo()
        },
        stop: function() {
            this.ytPlayer && this.ytPlayer.stopVideo()
        },
        setVolume: function(e) {
            var t;
            this.ytPlayer && (t = 100 * Math.max(0, Math.min(1, e)), this.ytPlayer.setVolume(t), this.onVolumeChange({
                volume: t
            }))
        },
        mute: function() {
            this.ytPlayer && (this.ytPlayer.mute(), this.onVolumeChange({
                mute: !0
            }))
        },
        unMute: function() {
            this.ytPlayer && (this.ytPlayer.unMute(), this.onVolumeChange({
                mute: !1
            }))
        },
        seek: function(e) {
            this.ytPlayer && (this.ytPlayer.seekTo(Math.max(0, Math.min(e, this.ytPlayer.getDuration())), !0), this.onSeekEnd())
        },
        setRate: function(e) {
            this.ytPlayer && this.ytPlayer.setPlaybackRate(Math.max(0, e))
        },
        onPlayerReady: function() {
            this.props.compProp.mute && this.mute(), this.setRate(this.props.compData.playbackSpeed || 1), this.handlePosterVisibilityOnce(), this.onLoadStart()
        },
        onPlayerStateChange: function(e) {
            var t = window.YT.PlayerState;
            switch (e.data) {
                case t.ENDED:
                    this.onPlayEnded();
                    break;
                case t.PLAYING:
                    this.onPlay();
                    break;
                case t.PAUSED:
                    this.onPause();
                    break;
                case t.BUFFERING:
                    this.onProgress();
                    break;
                case t.CUED:
            }
        },
        onLoadStart: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.LOAD,
                playbackState: a.playbackTypes.READY,
                volume: this.ytPlayer.getVolume() / 100,
                muted: this.ytPlayer.isMuted(),
                currentTime: this.ytPlayer.getCurrentTime(),
                progress: 0
            })
        },
        onTimeUpdate: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.TIME_UPDATE,
                currentTime: this.ytPlayer.getCurrentTime(),
                duration: this.ytPlayer.getDuration()
            })
        },
        onPlayEnded: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.PLAYSTATE,
                playbackState: a.playbackTypes.PLAY_ENDED
            })
        },
        onPlay: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.PLAYSTATE,
                playbackState: a.playbackTypes.PLAYING
            }), this.startSimulateTimeUpdate()
        },
        onPause: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.PLAYSTATE,
                playbackState: a.playbackTypes.PAUSED
            }), this.stopSimulateTimeUpdate()
        },
        onError: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.ERROR,
                error: a.errorTypes.VIDEO_GENERAL_ERROR
            }), this.stopSimulateTimeUpdate()
        },
        onProgress: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.PROGRESS,
                progress: this.ytPlayer.getDuration() * this.ytPlayer.getVideoLoadedFraction()
            })
        },
        onSeekStart: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.PLAYSTATE,
                playbackState: a.playbackTypes.SEEKING
            })
        },
        onSeekEnd: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.PLAYSTATE,
                playbackState: a.playbackTypes.SEEKING_ENDED
            })
        },
        onVolumeChange: function(t) {
            t = t || {};
            var i = (e.isNumber(t.volume) ? t.volume : this.ytPlayer.getVolume()) / 100,
                o = e.isBoolean(t.mute) ? t.mute : this.ytPlayer.isMuted();
            this.props.notifyMediaState({
                type: a.eventTypes.VOLUME,
                volume: i,
                muted: o
            })
        },
        onRateChange: function() {
            this.props.notifyMediaState({
                type: a.eventTypes.RATE,
                playbackRate: this.ytPlayer.getPlaybackRate()
            })
        },
        getSkinProperties: function() {
            var e = {
                    width: "100%"
                },
                t = this.props.compData.posterImage || {
                    uri: "//img.youtube.com/vi/" + this.props.compData.videoId + "/hqdefault.jpg"
                },
                i = this.getPosterImageComp(t, this.state.showVideo);
            return {
                "": {
                    "data-quality": this.props.mediaQuality,
                    "data-player-type": "youtube",
                    style: e
                },
                video: {},
                poster: i
            }
        }
    }
}), define("backgroundCommon/components/bgMedia", ["lodash", "react", "core", "santaProps", "imageClientApi", "image", "backgroundCommon/components/bgImage", "backgroundCommon/components/html5Video", "backgroundCommon/components/youtubeVideo", "utils"], function(e, t, i, o, a, s, n, r, p, d) {
    function y(t) {
        return e.includes(f, t) ? g : T
    }

    function l(e, t) {
        var i = {};
        return t === g.comp ? i = {
            ref: m.balataConsts.CONTENT,
            "data-type": g["data-type"]
        } : t === T.comp ? i = {
            ref: m.balataConsts.CONTENT,
            key: "img_" + e.bgEffectName,
            containerWidth: 0,
            containerHeight: 0,
            imageData: e.compData,
            displayMode: e.fittingType,
            alignType: e.alignType,
            "data-type": T["data-type"]
        } : t !== P.comp && t !== S.comp && t !== b.comp || (i = {
            ref: m.balataConsts.CONTENT,
            key: "vid_" + e.compData.videoId,
            notifyMediaState: e.notifyMediaState,
            isPlayingAllowed: e.isPlayingAllowed,
            setMediaAPI: e.setMediaAPI,
            mediaQuality: e.mediaQuality,
            compProp: e.compProp
        }), i
    }

    function c(e) {
        var t, i = e.compData,
            o = y(e.fittingType),
            a = {
                image: {
                    id: e.id + m.balataConsts.CONTENT,
                    componentType: o.comp,
                    skinPartData: {
                        skin: o.skin,
                        styleId: o.style
                    },
                    compData: i
                },
                poster: {
                    id: e.id + m.balataConsts.CONTENT,
                    componentType: o.comp,
                    skinPartData: {
                        skin: o.skin,
                        styleId: o.style
                    },
                    compData: i.posterImageRef
                },
                video: {
                    id: e.id + m.balataConsts.CONTENT,
                    componentType: P.comp,
                    skinPartData: {
                        skin: P.skin,
                        styleId: P.style
                    },
                    compData: i
                },
                youtube: {
                    id: e.id + m.balataConsts.CONTENT,
                    componentType: S.comp,
                    skinPartData: {
                        skin: S.skin,
                        styleId: S.style
                    },
                    compData: i
                },
                iframe: {
                    id: e.id + m.balataConsts.CONTENT,
                    componentType: b.comp,
                    skinPartData: {
                        skin: b.skin,
                        styleId: b.style
                    },
                    compData: i
                }
            };
        switch (i.type) {
            case "Image":
                t = a.image;
                break;
            case "WixVideo":
                t = e.enableVideo ? a.video : a.poster;
                break;
            case "Video":
                switch (i.videoType) {
                    case "YOUTUBE":
                        t = a.youtube
                }
        }
        return t
    }
    var u = i.compMixins,
        h = d.containerBackgroundUtils,
        m = d.mediaConsts,
        f = [a.fittingTypes.TILE],
        g = {
            comp: "wysiwyg.viewer.components.background.bgImage",
            skin: "skins.viewer.bgImage.bgImageSkin",
            style: "bgImage",
            "data-type": m.balataConsts.BG_IMAGE
        },
        T = {
            comp: "core.components.Image",
            skin: "skins.core.ImageNewSkinZoomable",
            style: "bgImage",
            "data-type": m.balataConsts.IMAGE
        },
        P = {
            comp: "wysiwyg.viewer.components.background.html5Video",
            skin: "skins.viewer.bgVideo.html5VideoSkin",
            style: "bgVideo"
        },
        S = {
            comp: "wysiwyg.viewer.components.background.youtubeVideo",
            skin: "skins.viewer.bgVideo.youtubeVideoSkin",
            style: "youtubeVideo"
        },
        b = {
            comp: "wysiwyg.viewer.components.background.iframeVideo",
            skin: "skins.viewer.bgVideo.iframeVideoSkin",
            style: "iframeVideo"
        };
    return {
        displayName: "bgMedia",
        mixins: [u.skinBasedComp],
        propTypes: e.defaults({
            id: t.PropTypes.string.isRequired,
            compData: t.PropTypes.object.isRequired,
            compProp: t.PropTypes.object,
            alignType: t.PropTypes.string,
            fittingType: t.PropTypes.string,
            mediaTransforms: t.PropTypes.object,
            bgEffectName: t.PropTypes.string,
            style: t.PropTypes.object.isRequired,
            isPlayingAllowed: t.PropTypes.bool,
            enableVideo: t.PropTypes.bool,
            mediaQuality: t.PropTypes.string,
            notifyMediaState: t.PropTypes.func,
            setMediaAPI: t.PropTypes.func,
            renderFixedPositionBackgrounds: o.Types.RenderFlags.renderFixedPositionBackgrounds
        }, o.santaTypesUtils.getSantaTypesByDefinition(s), o.santaTypesUtils.getSantaTypesByDefinition(n), o.santaTypesUtils.getSantaTypesByDefinition(r), o.santaTypesUtils.getSantaTypesByDefinition(p)),
        statics: {
            useSantaTypes: !0
        },
        getDefaultSkinName: function() {
            return "skins.viewer.balata.bgMediaSkin"
        },
        getMediaComponent: function() {
            var t = c(this.props),
                i = l(this.props, t.componentType),
                o = e.assign({
                    id: t.id
                }, i);
            return this.createChildComponent(t.compData, t.componentType, t.skinPartData, o)
        },
        getSkinProperties: function() {
            var t = h.getPositionByEffect(this.props.bgEffectName, this.props.renderFixedPositionBackgrounds),
                i = e.assign({}, this.props.style, {
                    position: t,
                    pointerEvents: this.props.bgEffectName ? "none" : "auto",
                    top: 0
                }),
                o = e.mapKeys(this.props.mediaTransforms, function(e, t) {
                    return "data-" + t
                });
            return {
                "": e.assign({
                    key: ["media", this.props.isPlayingAllowed ? "playback" : "no_playback", this.props.enableVideo ? "video" : "no_video"].join("_"),
                    children: this.getMediaComponent(),
                    style: i,
                    "data-effect": this.props.bgEffectName || "none",
                    "data-fitting": this.props.fittingType,
                    "data-align": this.props.alignType
                }, o)
            }
        }
    }
}), define("backgroundCommon/components/bgOverlay", ["react", "lodash", "core", "utils", "santaProps"], function(e, t, i, o, a) {
    function s(e, t) {
        return "url(" + o.urlUtils.joinURL(e, t.uri) + ")"
    }

    function n(e) {
        var t = {};
        return e.colorOverlay && (t.backgroundColor = o.colorParser.getColor(e.colorsMap, e.colorOverlay, e.colorOverlayOpacity)), e.imageOverlay && (t.backgroundImage = s(e.staticMediaUrl, e.imageOverlay)), t
    }

    function r(e) {
        var i = {
                width: "100%",
                height: "100%",
                position: "absolute"
            },
            o = n(e);
        return t.assign(i, o)
    }

    function p(e, t, i) {
        return t && o.containerBackgroundUtils.isFullScreenByEffect(e, i)
    }

    function d() {
        var e = t.assign({
            position: "absolute"
        }, this.props.style, {
            width: "100%",
            height: "100%"
        });
        return p(this.props.bgEffectName, this.props.fixedBackgroundColorBalata, this.props.renderFixedPositionBackgrounds) && t.assign(e, {
            top: 0,
            position: "fixed"
        }), e
    }
    return {
        displayName: "bgOverlay",
        mixins: [i.compMixins.skinBasedComp],
        propTypes: {
            style: e.PropTypes.object,
            colorOverlay: e.PropTypes.string,
            colorOverlayOpacity: e.PropTypes.number,
            imageOverlay: e.PropTypes.object,
            bgEffectName: e.PropTypes.string,
            colorsMap: a.Types.Theme.colorsMap.isRequired,
            staticMediaUrl: a.Types.ServiceTopology.staticMediaUrl,
            fixedBackgroundColorBalata: a.Types.BrowserFlags.fixedBackgroundColorBalata.isRequired,
            renderFixedPositionBackgrounds: a.Types.RenderFlags.renderFixedPositionBackgrounds
        },
        statics: {
            useSantaTypes: !0
        },
        getSkinProperties: function() {
            var e = d.call(this),
                t = r(this.props),
                i = {
                    "": {
                        style: e
                    }
                };
            return i[o.balataConsts.OVERLAY] = {
                style: t
            }, i
        }
    }
}), define("backgroundCommon/components/iframeVideoFactory", ["lodash", "react", "utils", "pmrpc", "backgroundCommon/mixins/videoPlayerMixin"], function(e, t, i, o, a) {
    function s(e) {
        var i = e.url,
            s = e.id;
        return {
            displayName: e.displayName || "iframeVideo",
            mixins: [a],
            statics: {
                useSantaTypes: !0
            },
            getInitialState: function() {
                return this.player = null, {
                    loadVideo: !1,
                    showVideo: !1
                }
            },
            componentDidMount: function() {
                this.props.setMediaAPI(this.mediaAPI), this.props.notifyMediaState({
                    type: n.eventTypes.MOUNT,
                    playbackState: n.playbackTypes.LOADING
                }), this.props.compProp.autoplay && this.props.isPlayingAllowed && this.play()
            },
            componentDidUpdate: function() {
                this.setRate(this.props.compData.playbackSpeed || 1)
            },
            componentWillUnmount: function() {
                this.props.setMediaAPI(null), this.player && this.player.removeEventListener("timeupdate", this.handlePosterVisibilityOnce), this.removeVideoSecurely()
            },
            onVideoFrameReady: function() {
                o.api.request(s, {
                    target: this.refs.video
                }).then(function(e) {
                    this.player = e, this.player.set("url", {
                        loop: this.props.compProp.loop,
                        mute: this.props.compProp.mute,
                        autoplay: !0,
                        rate: this.props.compData.playbackSpeed || 1,
                        preload: this.props.compData.preload || "none",
                        onEnded: this.onPlayEnded,
                        onError: this.onError,
                        onLoadStart: this.onLoadStart,
                        onPause: this.onPause,
                        onPlay: this.onPlay,
                        onProgress: this.onProgress,
                        onRateChange: this.onRateChange,
                        onSeeked: this.onSeekEnd,
                        onSeeking: this.onSeekStart,
                        onStalled: this.onStalled,
                        onTimeUpdate: this.onTimeUpdate,
                        onVolumeChange: this.onVolumeChange
                    }), this.player.addEventListener("timeupdate", this.handlePosterVisibilityOnce)
                }.bind(this))
            },
            handlePosterVisibilityOnce: function() {
                this.player.getCurrentTime().then(function(e) {
                    (e > 0 || this.props.compProp.autoplay) && (this.player.removeEventListener("timeupdate", this.handlePosterVisibilityOnce), this.setState({
                        showVideo: !0
                    }))
                }.bind(this))
            },
            resetPosterState: function() {
                this.state.showVideo && (this.setState({
                    showVideo: !1
                }), this.player.addEventListener("timeupdate", this.handlePosterVisibilityOnce))
            },
            removeVideoSecurely: function() {
                this.player && this.player.reset()
            },
            play: function() {
                this.player ? this.player.play() : this.setState({
                    loadVideo: !0
                })
            },
            pause: function() {
                this.player && this.player.pause()
            },
            stop: function() {
                this.player && (this.pause(), this.seek(0), this.resetPosterState())
            },
            setVolume: function(e) {
                this.player && this.player.setVolume(e)
            },
            mute: function() {
                this.player && this.player.setMute(!0)
            },
            unMute: function() {
                this.player && this.player.setMute(!1)
            },
            seek: function(e) {
                this.player && this.player.seek(e)
            },
            setRate: function(e) {
                this.player && this.player.setRate(e)
            },
            onLoadStart: function(e) {
                this.props.notifyMediaState({
                    type: n.eventTypes.LOAD,
                    playbackState: n.playbackTypes.READY,
                    volume: e.volume,
                    muted: e.muted,
                    currentTime: e.currentTime,
                    progress: 0
                })
            },
            onTimeUpdate: function(e) {
                this.props.notifyMediaState({
                    type: n.eventTypes.TIME_UPDATE,
                    currentTime: e.currentTime
                })
            },
            onPlayEnded: function() {
                this.props.notifyMediaState({
                    type: n.eventTypes.PLAYSTATE,
                    playbackState: n.playbackTypes.PLAY_ENDED
                })
            },
            onPlay: function() {
                this.props.notifyMediaState({
                    type: n.eventTypes.PLAYSTATE,
                    playbackState: n.playbackTypes.PLAYING
                })
            },
            onPause: function() {
                this.props.notifyMediaState({
                    type: n.eventTypes.PLAYSTATE,
                    playbackState: n.playbackTypes.PAUSED
                })
            },
            onError: function(e) {
                e.networkState === e.NETWORK_NO_SOURCE ? this.props.notifyMediaState({
                    type: n.eventTypes.ERROR,
                    error: n.errorTypes.NO_VIDEO_FOUND
                }) : this.props.notifyMediaState({
                    type: n.eventTypes.ERROR,
                    error: n.errorTypes.VIDEO_GENERAL_ERROR
                })
            },
            onStalled: function(e) {
                e.readyState === e.HAVE_NOTHING && this.props.notifyMediaState({
                    type: n.eventTypes.ERROR,
                    error: n.errorTypes.NO_VIDEO_FOUND
                })
            },
            onProgress: function(e) {
                this.props.notifyMediaState({
                    type: n.eventTypes.PROGRESS,
                    progress: e.progress
                })
            },
            onSeekStart: function() {
                this.props.notifyMediaState({
                    type: n.eventTypes.PLAYSTATE,
                    playbackState: n.playbackTypes.SEEKING
                })
            },
            onSeekEnd: function() {
                this.props.notifyMediaState({
                    type: n.eventTypes.PLAYSTATE,
                    playbackState: n.playbackTypes.SEEKING_ENDED
                })
            },
            onVolumeChange: function(e) {
                this.props.notifyMediaState({
                    type: n.eventTypes.VOLUME,
                    volume: e.volume,
                    muted: e.muted
                })
            },
            onRateChange: function(e) {
                this.props.notifyMediaState({
                    type: n.eventTypes.RATE,
                    playbackRate: e.playbackRate
                })
            },
            getVideo: function() {
                var e = {};
                return this.state.loadVideo && (e = t.DOM.iframe({
                    ref: "video",
                    id: this.props.id + "video",
                    frameBorder: 0,
                    allowFullscreen: !0,
                    src: i,
                    onLoad: this.onVideoFrameReady
                })), e
            },
            getSkinProperties: function() {
                var e = {
                        width: "100%"
                    },
                    t = this.props.compData.posterImageRef,
                    i = this.getPosterImageComp(t, this.state.showVideo);
                return {
                    "": {
                        "data-quality": this.props.mediaQuality,
                        "data-player-type": "iframe",
                        style: e
                    },
                    video: this.getVideo(),
                    poster: i
                }
            }
        }
    }
    var n = i.mediaConsts;
    return {
        getIframeVideoComponent: s
    }
}), define("backgroundCommon/components/iframeVideo", ["backgroundCommon/components/iframeVideoFactory"], function(e) {
    return e.getIframeVideoComponent({
        url: "//wix-private.github.io/video-fx-player/index.html",
        id: "wix-video-fx-player",
        displayName: "iframeVideo"
    })
}), define("backgroundCommon", ["backgroundCommon/mixins/backgroundDetectionMixin", "backgroundCommon/components/bgImage", "backgroundCommon/components/bgMedia", "backgroundCommon/components/bgOverlay", "backgroundCommon/components/html5Video", "backgroundCommon/components/youtubeVideo", "backgroundCommon/components/iframeVideo"], function(e, t, i, o, a, s, n) {
    return {
        mixins: {
            backgroundDetectionMixin: e
        },
        components: {
            bgImage: t,
            bgMedia: i,
            bgOverlay: o,
            html5Video: a,
            youtubeVideo: s,
            iframeVideo: n
        }
    }
});
//# sourceMappingURL=backgroundCommon.min.js.map
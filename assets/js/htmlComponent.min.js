"use strict";
define("htmlComponent", ["lodash", "react", "core", "utils", "santaProps"], function(o, t, e, s, n) {
    function r() {
        var o = this.props.compData.url,
            t = "external" === this.props.compData.sourceType,
            e = this.props.serviceTopologyStaticHTMLComponentUrl,
            n = c.parseUrl(this.props.externalBaseUrl).protocol;
        return !t && s.stringUtils.startsWith(o, "html/") && (o = e + o), o = c.addProtocolIfMissing(o, n), e = c.addProtocolIfMissing(e), "https:" === n && (o = c.setProtocol(o, n)), t || (o = o.replace("//static.wixstatic.com", e)), o
    }

    function i(o) {
        return !!o.url
    }

    function a() {
        var t = {
                sandbox: "allow-same-origin allow-forms allow-popups allow-scripts allow-pointer-lock"
            },
            e = {
                width: "100%",
                height: "100%",
                ref: "iframe",
                onLoad: this.onLoad,
                "data-src": i(this.props.compData) ? r.call(this) : ""
            };
        return p.call(this) ? o.assign(e, t) : e
    }

    function p() {
        return this.props.useSandboxInHTMLComp
    }
    var l = e.compMixins,
        c = s.urlUtils;
    return {
        displayName: "HtmlComponent",
        mixins: [l.skinBasedComp],
        propTypes: {
            compData: n.Types.Component.compData,
            serviceTopologyStaticHTMLComponentUrl: n.Types.ServiceTopology.staticHTMLComponentUrl,
            useSandboxInHTMLComp: n.Types.RendererModel.useSandboxInHTMLComp,
            os: n.Types.Browser.os.isRequired,
            registerComponentToPostMessage: n.Types.HtmlPostMessage.registerComponent.isRequired,
            unRegisterComponentFromPostMessage: n.Types.HtmlPostMessage.unRegisterComponent.isRequired,
            externalBaseUrl: n.Types.PublicModel.externalBaseUrl
        },
        statics: {
            useSantaTypes: !0
        },
        onLoad: function() {
            this.props.registerComponentToPostMessage(this.props.id, this.refs.iframe.contentWindow)
        },
        getInitialState: function() {
            return {
                $content: i(this.props.compData) ? "hasContent" : "noContent"
            }
        },
        componentWillUnmount: function() {
            this.props.unRegisterComponentFromPostMessage(this.props.id)
        },
        componentWillReceiveProps: function() {
            this.setState({
                $content: i(this.props.compData) ? "hasContent" : "noContent"
            })
        },
        getSkinProperties: function() {
            var e = {};
            return !0 === this.props.os.ios && o.assign(e, {
                overflow: "scroll",
                "-webkit-overflow-scrolling": "touch"
            }), {
                "": {
                    style: e
                },
                iFrameHolder: {
                    children: [t.DOM.iframe(a.call(this))]
                }
            }
        }
    }
});
//# sourceMappingURL=htmlComponent.min.js.map
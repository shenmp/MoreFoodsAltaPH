"use strict";
define("datePicker/subComponents/day", ["lodash", "react", "core", "santaProps"], function(e, t, s, i) {
    return {
        displayName: "Day",
        propTypes: {
            id: t.PropTypes.string.isRequired,
            styleId: t.PropTypes.string.isRequired,
            dateUtils: t.PropTypes.object.isRequired,
            day: t.PropTypes.object.isRequired,
            today: t.PropTypes.object.isRequired,
            calendarDate: t.PropTypes.object.isRequired,
            closeCalendar: t.PropTypes.func.isRequired,
            onDateChange: t.PropTypes.func.isRequired,
            isMobileView: i.Types.isMobileView.isRequired,
            isMobileDevice: i.Types.Device.isMobileDevice.isRequired,
            allowPastDates: t.PropTypes.bool,
            allowFutureDates: t.PropTypes.bool,
            disabledDates: t.PropTypes.arrayOf(t.PropTypes.string),
            disabledDaysOfWeek: t.PropTypes.arrayOf(t.PropTypes.number),
            minDate: t.PropTypes.string,
            maxDate: t.PropTypes.string,
            selectedDate: t.PropTypes.object
        },
        statics: {
            useSantaTypes: !0
        },
        mixins: [s.compMixins.skinBasedComp],
        getInitialState: function() {
            return {
                $mobile: this.props.isMobileDevice || this.props.isMobileView ? "mobile" : "notMobile"
            }
        },
        componentWillMount: function() {
            this.isDisabled = this.isDayDisabled(this.props)
        },
        componentWillReceiveProps: function(e) {
            this.isDisabled = this.isDayDisabled(e)
        },
        isSpecificDateDisable: function(t) {
            return e.some(t.disabledDates, function(e) {
                return t.dateUtils.helpers.isSameDay(t.day, new Date(e))
            })
        },
        isWeekDayDisable: function(t) {
            return e.includes(t.disabledDaysOfWeek, t.dateUtils.helpers.getDay(t.day))
        },
        isDisallowedPastDate: function(t) {
            return e.isBoolean(t.allowPastDates) && !t.allowPastDates && t.dateUtils.helpers.isBefore(t.day, t.today)
        },
        isDisallowedFutureDate: function(t) {
            return e.isBoolean(t.allowFutureDates) && !t.allowFutureDates && t.dateUtils.helpers.isAfter(t.day, t.today)
        },
        isBeforeMinDate: function(e) {
            var t = e.dateUtils.helpers,
                s = t.getStartOfDay(new Date(e.minDate));
            return e.minDate && t.isBefore(e.day, s)
        },
        isAfterMaxDate: function(e) {
            return e.maxDate && e.dateUtils.helpers.isAfter(e.day, new Date(e.maxDate))
        },
        isDayDisabled: function(e) {
            return this.isSpecificDateDisable(e) || this.isWeekDayDisable(e) || this.isDisallowedPastDate(e) || this.isDisallowedFutureDate(e) || this.isBeforeMinDate(e) || this.isAfterMaxDate(e)
        },
        getCssClasses: function() {
            var e = this.props.dateUtils,
                t = this.props.day,
                s = {};
            return e.helpers.isSameMonth(t, this.props.calendarDate) ? this.isDisabled ? s.disabled = !0 : e.helpers.isSameDay(t, this.props.selectedDate) ? s.selected = !0 : e.helpers.isSameDay(t, this.props.today) && (s.today = !0) : s.hidden = !0, this.classSet(s)
        },
        handleDayClick: function() {
            this.props.onDateChange(this.props.day), this.props.closeCalendar()
        },
        getSkinProperties: function() {
            return {
                "": {
                    onMouseDown: this.isDisabled ? null : this.handleDayClick,
                    className: this.getCssClasses()
                },
                dayContent: {
                    children: this.props.dateUtils.helpers.getDate(this.props.day)
                }
            }
        }
    }
}), define("datePicker/subComponents/month", ["react", "lodash", "core", "santaProps", "datePicker/subComponents/day"], function(e, t, s, i, a) {
    return {
        displayName: "Month",
        propTypes: t.assign({
            id: e.PropTypes.string.isRequired,
            styleId: e.PropTypes.string.isRequired,
            dateUtils: e.PropTypes.object.isRequired,
            calendarDate: e.PropTypes.object.isRequired,
            today: e.PropTypes.object.isRequired,
            closeCalendar: e.PropTypes.func.isRequired,
            onDateChange: e.PropTypes.func.isRequired,
            isMobileView: i.Types.isMobileView.isRequired,
            isMobileDevice: i.Types.Device.isMobileDevice.isRequired,
            allowPastDates: e.PropTypes.bool,
            allowFutureDates: e.PropTypes.bool,
            disabledDates: e.PropTypes.arrayOf(e.PropTypes.string),
            disabledDaysOfWeek: e.PropTypes.arrayOf(e.PropTypes.number),
            minDate: e.PropTypes.string,
            maxDate: e.PropTypes.string,
            selectedDate: e.PropTypes.object
        }, i.santaTypesUtils.getSantaTypesByDefinition(a)),
        statics: {
            useSantaTypes: !0
        },
        mixins: [s.compMixins.skinBasedComp],
        getInitialState: function() {
            return {
                $mobile: this.props.isMobileDevice || this.props.isMobileView ? "mobile" : "notMobile"
            }
        },
        isWeekInMonth: function(e) {
            var t = this.props.dateUtils,
                s = this.props.calendarDate,
                i = t.helpers.addDays(e, 6);
            return t.helpers.isSameMonth(e, s) || t.helpers.isSameMonth(i, s)
        },
        generateDays: function(e) {
            var s = this.props.dateUtils,
                i = s.helpers.getISOWeek(e);
            return t(s.constants.NUMBER_OF_DAYS_IN_WEEK).range().map(function(t) {
                return this.createChildComponent({}, "wysiwyg.viewer.components.Day", "day", {
                    id: this.props.id + "week" + i + "day" + t,
                    ref: this.props.id + "week" + i + "day" + t,
                    key: this.props.id + "week" + i + "day" + t,
                    style: {},
                    dateUtils: this.props.dateUtils,
                    day: s.helpers.addDays(e, t),
                    today: this.props.today,
                    onDateChange: this.props.onDateChange,
                    closeCalendar: this.props.closeCalendar,
                    selectedDate: this.props.selectedDate,
                    calendarDate: this.props.calendarDate,
                    disabledDates: this.props.disabledDates,
                    disabledDaysOfWeek: this.props.disabledDaysOfWeek,
                    allowPastDates: this.props.allowPastDates,
                    allowFutureDates: this.props.allowFutureDates,
                    minDate: this.props.minDate,
                    maxDate: this.props.maxDate
                })
            }.bind(this)).value()
        },
        generateWeeks: function() {
            var s = this.props.dateUtils,
                i = s.helpers.getStartDayOfTheMonth(this.props.calendarDate),
                a = s.helpers.getStartDayOfTheWeek(i, {
                    weekStartsOn: 1
                });
            return t(s.constants.MAX_NUMBER_OF_WEEKS).range().map(function(e) {
                return this.props.dateUtils.helpers.addWeeks(a, e)
            }.bind(this)).filter(function(e) {
                return this.isWeekInMonth(e)
            }.bind(this)).map(function(t) {
                return e.DOM.div({
                    className: this.classSet({
                        week: !0
                    })
                }, this.generateDays(t))
            }.bind(this)).value()
        },
        getSkinProperties: function() {
            return {
                "": {
                    children: this.generateWeeks()
                }
            }
        }
    }
}), define("datePicker/subComponents/calendar", ["react", "reactDOM", "lodash", "core", "santaProps", "datePicker/subComponents/month"], function(e, t, s, i, a, o) {
    return {
        displayName: "Calendar",
        propTypes: s.assign({
            id: e.PropTypes.string.isRequired,
            styleId: e.PropTypes.string.isRequired,
            dateUtils: e.PropTypes.object.isRequired,
            calendarDate: e.PropTypes.object.isRequired,
            today: e.PropTypes.object.isRequired,
            closeCalendar: e.PropTypes.func.isRequired,
            onDateChange: e.PropTypes.func.isRequired,
            isMobileView: a.Types.isMobileView.isRequired,
            isMobileDevice: a.Types.Device.isMobileDevice.isRequired,
            siteWidth: a.Types.siteWidth.isRequired,
            siteScrollingBlocker: a.Types.SiteAspects.siteScrollingBlocker.isRequired,
            forceBackground: a.Types.forceBackground.isRequired,
            disableForcedBackground: a.Types.disableForcedBackground.isRequired,
            allowPastDates: e.PropTypes.bool,
            allowFutureDates: e.PropTypes.bool,
            disabledDates: e.PropTypes.arrayOf(e.PropTypes.string),
            disabledDaysOfWeek: e.PropTypes.arrayOf(e.PropTypes.number),
            minDate: e.PropTypes.string,
            maxDate: e.PropTypes.string,
            selectedDate: e.PropTypes.object
        }, a.santaTypesUtils.getSantaTypesByDefinition(o)),
        statics: {
            useSantaTypes: !0
        },
        mixins: [i.compMixins.skinBasedComp, i.compMixins.blockOuterScrollMixin],
        getInitialState: function() {
            return {
                calendarDate: this.props.calendarDate,
                shouldShowYearSelection: !1,
                $mobile: this.props.isMobileDevice || this.props.isMobileView ? "mobile" : "notMobile"
            }
        },
        componentWillReceiveProps: function(e) {
            this.props.dateUtils.helpers.isEqual(this.props.calendarDate, e.calendarDate) || this.setState({
                calendarDate: e.calendarDate
            })
        },
        componentDidUpdate: function() {
            this.state.shouldShowYearSelection && this.scrollToCurrentYearOption()
        },
        generateDayNames: function() {
            var t = this.props.dateUtils,
                i = t.helpers.getStartDayOfTheWeek(this.state.calendarDate, {
                    weekStartsOn: 1
                });
            return s(t.constants.NUMBER_OF_DAYS_IN_WEEK).range().map(function(t) {
                var s = this.props.dateUtils.helpers.addDays(i, t);
                return e.DOM.div({
                    className: this.classSet({
                        "day-name": !0
                    })
                }, this.props.dateUtils.helpers.getDayNameMin(s))
            }.bind(this)).value()
        },
        generateMonth: function() {
            return this.createChildComponent({}, "wysiwyg.viewer.components.Month", "month", {
                id: this.props.id + "month",
                ref: this.props.id + "month",
                style: {},
                dateUtils: this.props.dateUtils,
                selectedDate: this.props.selectedDate,
                calendarDate: this.state.calendarDate,
                today: this.props.today,
                onDateChange: this.props.onDateChange,
                closeCalendar: this.props.closeCalendar,
                disabledDates: this.props.disabledDates,
                disabledDaysOfWeek: this.props.disabledDaysOfWeek,
                allowPastDates: this.props.allowPastDates,
                allowFutureDates: this.props.allowFutureDates,
                minDate: this.props.minDate,
                maxDate: this.props.maxDate
            })
        },
        setYear: function(e) {
            this.setState({
                calendarDate: this.props.dateUtils.helpers.setYear(this.state.calendarDate, e),
                shouldShowYearSelection: !1
            })
        },
        subYear: function() {
            this.setState({
                calendarDate: this.props.dateUtils.helpers.subYears(this.state.calendarDate, 1)
            })
        },
        subMonth: function() {
            this.setState({
                calendarDate: this.props.dateUtils.helpers.subMonths(this.state.calendarDate, 1)
            })
        },
        addMonth: function() {
            this.setState({
                calendarDate: this.props.dateUtils.helpers.addMonths(this.state.calendarDate, 1)
            })
        },
        addYear: function() {
            this.setState({
                calendarDate: this.props.dateUtils.helpers.addYears(this.state.calendarDate, 1)
            })
        },
        getCurrentMonth: function(e, t) {
            var s = "mobile" === this.state.$mobile ? e : t;
            return this.props.dateUtils.helpers.getDateByFormat(this.state.calendarDate, s)
        },
        toggleYearSelection: function() {
            this.setState({
                shouldShowYearSelection: !this.state.shouldShowYearSelection
            })
        },
        scrollToCurrentYearOption: function() {
            var e = t.findDOMNode(this.refs.yearOptionsWrapper),
                s = t.findDOMNode(this.refs.selectedYearOptionItem);
            s && (e.scrollTop = s.offsetTop - e.offsetHeight / 2 + s.offsetHeight / 2)
        },
        generateYearOption: function(t) {
            var s = this.props.dateUtils.helpers.getYear(this.state.calendarDate) === t,
                i = {
                    onClick: this.setYear.bind(this, t),
                    className: this.classSet({
                        "year-option-item": !0,
                        selected: s
                    }),
                    key: "year" + t,
                    ref: s ? "selectedYearOptionItem" : null
                };
            return e.DOM.li(i, e.DOM.span({
                className: this.classSet({
                    "year-content": !0
                })
            }, t))
        },
        generateYearOptionsList: function() {
            var t = this.props.dateUtils.constants,
                i = s(t.MIN_YEAR_OPTION_ITEM).range(t.MAX_YEAR_OPTION_ITEM).map(this.generateYearOption).value();
            return e.DOM.ul({
                ref: "yearOptionsList",
                className: this.classSet({
                    "year-options-list": !0
                })
            }, i)
        },
        createOverlay: function(e) {
            return i.componentUtils.fullScreenOverlay.createOverlay(e, {
                siteWidth: this.props.siteWidth,
                siteScrollingBlocker: this.props.siteScrollingBlocker,
                forceBackground: this.props.forceBackground,
                disableForcedBackground: this.props.disableForcedBackground,
                isMobileDevice: this.props.isMobileDevice,
                overlayBackgroundOpacity: "0.7"
            })
        },
        getSkinProperties: function() {
            var e = {
                previousYearNav: {
                    onClick: this.subYear
                },
                previousMonthNav: {
                    onClick: this.subMonth
                },
                currentMonthWithYear: {
                    onClick: this.toggleYearSelection,
                    children: this.getCurrentMonth(this.props.dateUtils.constants.DATE_FORMAT.MMM_YYYY, this.props.dateUtils.constants.DATE_FORMAT.MMMM_YYYY)
                },
                currentMonth: {
                    children: this.getCurrentMonth(this.props.dateUtils.constants.DATE_FORMAT.MMM, this.props.dateUtils.constants.DATE_FORMAT.MMMM)
                },
                previousYear: {
                    children: this.props.dateUtils.helpers.getDateByFormat(this.props.dateUtils.helpers.subYears(this.state.calendarDate, 1), this.props.dateUtils.constants.DATE_FORMAT.YYYY)
                },
                currentYear: {
                    onClick: this.toggleYearSelection,
                    children: this.props.dateUtils.helpers.getDateByFormat(this.state.calendarDate, this.props.dateUtils.constants.DATE_FORMAT.YYYY)
                },
                nextYear: {
                    children: this.props.dateUtils.helpers.getDateByFormat(this.props.dateUtils.helpers.addYears(this.state.calendarDate, 1), this.props.dateUtils.constants.DATE_FORMAT.YYYY)
                },
                nextMonthNav: {
                    onClick: this.addMonth
                },
                nextYearNav: {
                    onClick: this.addYear
                },
                dayNames: this.state.shouldShowYearSelection ? null : {
                    children: this.generateDayNames()
                },
                month: this.state.shouldShowYearSelection ? null : this.generateMonth(),
                yearOptionsWrapper: this.state.shouldShowYearSelection ? {
                    onWheel: this.blockOuterScroll,
                    children: this.generateYearOptionsList()
                } : null
            };
            return "mobile" === this.state.$mobile ? this.createOverlay(e) : e
        }
    }
}), define("datePicker/subComponents/datePickerComp", ["lodash", "core", "textCommon", "santaProps", "siteUtils", "datePicker/subComponents/calendar"], function(e, t, s, i, a, o) {
    function r(e) {
        var t = null;
        return "today" === e && (this.dateUtils ? t = this.dateUtils.helpers.getStartOfToday() : (t = new Date).setHours(0, 0, 0, 0)), t
    }
    var n = function(s, i) {
        var a = e.get(i, "props.defaultTextType");
        return e.assign({
            selectedDate: e.get(s, "selectedDate", r.call(this, a))
        }, t.compMixins.validatableWithSyncMixin.getPublicState(s))
    };
    return {
        displayName: "DatePicker",
        propTypes: e.assign({
            compData: i.Types.Component.compData.isRequired,
            compProp: i.Types.Component.compProp.isRequired,
            id: i.Types.Component.id.isRequired,
            styleId: i.Types.Component.styleId.isRequired,
            shouldResetComponent: i.Types.RenderFlags.shouldResetComponent.isRequired,
            componentPreviewState: i.Types.RenderFlags.componentPreviewState,
            windowClickEventAspect: i.Types.SiteAspects.windowClickEventAspect.isRequired,
            isMobileView: i.Types.isMobileView.isRequired,
            isMobileDevice: i.Types.Device.isMobileDevice.isRequired
        }, i.santaTypesUtils.getSantaTypesByDefinition(o)),
        statics: {
            useSantaTypes: !0,
            behaviors: e.assign({
                setValue: {
                    methodName: "setValue",
                    params: ["value"]
                }
            }, t.compMixins.validatableWithSyncMixin.VALIDATABLE_WITH_SYNC_BEHAVIORS, t.compMixins.inputFocusMixin.INPUT_FOCUS_BEHAVIORS)
        },
        mixins: [t.compMixins.skinBasedComp, t.compMixins.runTimeCompData, t.compMixins.inputFocusMixin, s.textScaleMixin, t.compMixins.validatableWithSyncMixin.validatableWithSync, t.compMixins.compStateMixin(n)],
        getInitialState: function() {
            return e.assign(n(), {
                shouldShowCalendar: !1,
                dateUtilsInit: !1,
                selectedDate: r.call(this, this.props.compProp.defaultTextType),
                $mobile: this.props.isMobileDevice || this.props.isMobileView ? "mobile" : "notMobile"
            })
        },
        setValue: function(e) {
            this.setState({
                selectedDate: e
            })
        },
        focus: function() {
            this.refs.input.focus()
        },
        blur: function() {
            this.refs.input.blur()
        },
        componentWillReceiveProps: function(t) {
            var s = {},
                i = t.compProp.defaultTextType !== this.props.compProp.defaultTextType,
                a = t.shouldResetComponent && this.props.shouldResetComponent !== t.shouldResetComponent;
            a && (this.hideValidityIndication(), this.closeCalendar(), e.assign(s, {
                selectedDate: r.call(this, t.compProp.defaultTextType)
            })), i && !a && e.assign(s, {
                selectedDate: r.call(this, t.compProp.defaultTextType)
            }), e.isEmpty(s) || this.setState(s)
        },
        componentDidMount: function() {
            this.props.windowClickEventAspect.registerToDocumentClickEvent(this.props.id);
            var e = this;
            requirejs(["dateUtils"], function(t) {
                e.isMounted() && (e.dateUtils = t, e.setState({
                    dateUtilsInit: !0
                }))
            })
        },
        componentWillUnmount: function() {
            this.props.windowClickEventAspect.unRegisterToDocumentClickEvent(this.props.id)
        },
        onDocumentClick: function(t) {
            var s = t.target.className,
                i = t.target.id,
                a = this.props.styleId,
                o = e.includes(i, this.props.id) && e.includes(s, a + "input"),
                r = this.props.isMobileDevice || this.props.isMobileView ? !e.isEqual(i, this.props.id + "calendar") : e.includes(s, a + "calendar");
            !this.state.shouldShowCalendar || o || r || this.handleInputBlur()
        },
        openCalendar: function(e) {
            this.setState({
                shouldShowCalendar: !0
            }, e)
        },
        closeCalendar: function(e) {
            this.setState({
                shouldShowCalendar: !1
            }, e)
        },
        toggleCalendar: function() {
            this.state.shouldShowCalendar ? this.handleInputBlur() : this.handleInputFocus()
        },
        onDateChange: function(e) {
            if (!this.dateUtils.helpers.isEqual(this.state.selectedDate, e)) {
                var t = {
                    selectedDate: e
                };
                this.setState(t, function() {
                    this.handleAction(a.constants.ACTION_TYPES.CHANGE)
                }.bind(this))
            }
        },
        isPreviewState: function(t) {
            return e.includes(this.props.componentPreviewState, t)
        },
        getCalendarProperties: function() {
            var e = this.dateUtils.helpers.getStartOfToday();
            return {
                id: this.props.id + "calendar",
                ref: this.props.id + "calendar",
                style: {},
                dateUtils: this.dateUtils,
                calendarDate: this.state.selectedDate || e,
                today: e,
                closeCalendar: this.closeCalendar,
                onDateChange: this.onDateChange,
                allowPastDates: this.props.compData.allowPastDates,
                allowFutureDates: this.props.compData.allowFutureDates,
                disabledDates: this.props.compData.disabledDates,
                disabledDaysOfWeek: this.props.compData.disabledDaysOfWeek,
                minDate: this.props.compData.minDate,
                maxDate: this.props.compData.maxDate,
                selectedDate: this.state.selectedDate
            }
        },
        getCalendar: function() {
            return this.state.shouldShowCalendar && this.state.dateUtilsInit ? this.createChildComponent({}, "wysiwyg.viewer.components.Calendar", "calendar", this.getCalendarProperties()) : {}
        },
        getDateInputText: function() {
            var e = "";
            return this.state.selectedDate && this.state.dateUtilsInit && (e = this.dateUtils.helpers.getDateByFormat(this.state.selectedDate, this.props.compProp.dateFormat)), e
        },
        getPlaceholderText: function() {
            var e = this.props.compProp.placeholder;
            return this.state.selectedDate || !e ? "" : e
        },
        getHostSkinProperties: function() {
            var e = {
                focused: this.state.shouldShowCalendar,
                "read-only": !!this.props.compProp.readOnly,
                invalid: !this.isValid(),
                "with-validation-indication": this.shouldShowValidityIndication()
            };
            return e[this.props.compProp.textAlignment + "-direction"] = !0, {
                className: this.classSet(e),
                "data-disabled": !!this.props.compProp.isDisabled
            }
        },
        handleInputFocus: function(e) {
            this.openCalendar(this.handleAction.bind(this, a.constants.ACTION_TYPES.FOCUS, e))
        },
        handleInputBlur: function(e) {
            this.closeCalendar(this.handleAction.bind(this, a.constants.ACTION_TYPES.BLUR, e))
        },
        getInputSkinProperties: function() {
            var t = !!this.props.compProp.readOnly,
                s = !!this.props.compProp.isDisabled,
                i = this.props.compProp.textPadding,
                a = "right" === this.props.compProp.textAlignment ? {
                    paddingRight: i
                } : {
                    paddingLeft: i
                };
            return {
                value: this.getDateInputText(),
                placeholder: this.getPlaceholderText(),
                onFocus: t || s ? null : this.handleInputFocus,
                onBlur: t || s ? null : this.handleInputBlur,
                readOnly: t,
                disabled: s,
                style: e.merge(this.getFontSize(), a)
            }
        },
        getSkinProperties: function() {
            return {
                "": this.getHostSkinProperties(),
                inputWrapper: {
                    onClick: !this.state.dateUtilsInit || this.props.compProp.isDisabled || this.props.compProp.readOnly ? null : this.toggleCalendar
                },
                input: this.getInputSkinProperties(),
                calendar: this.getCalendar()
            }
        }
    }
}), define("datePicker", ["datePicker/subComponents/datePickerComp", "datePicker/subComponents/calendar", "datePicker/subComponents/month", "datePicker/subComponents/day"], function(e, t, s, i) {
    return {
        datePicker: e,
        calendar: t,
        month: s,
        day: i
    }
});
//# sourceMappingURL=datePicker.min.js.map
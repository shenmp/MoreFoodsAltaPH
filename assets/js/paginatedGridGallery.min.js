"use strict";
define("paginatedGridGallery", ["lodash", "react", "santaProps", "core", "utils", "siteUtils", "coreUtils", "imageClientApi", "galleriesCommon", "image"], function(t, e, i, o, s, n, r, a, l, p) {
    function h(t, e, i, o, s, n) {
        var r = S.getItemWidth(t.margin, t.numCols, e, P.getSkinWidthDiff(s)),
            a = S.getItemHeight(t.margin, i, o, P.getSkinHeightDiff(s)),
            l = e - P.getSkinWidthDiff(s) + t.margin,
            p = i - P.getSkinHeightDiff(s) + t.margin;
        return {
            width: "Shrink" === n ? r : l,
            height: "Shrink" === n ? a : p
        }
    }

    function d(t, e) {
        return {
            visibility: "visible",
            position: "absolute",
            cursor: "pointer",
            padding: 0,
            left: parseInt(t.props.style.left, 10) + P.getSkinWidthDiff(e) / 2,
            top: parseInt(t.props.style.top, 10),
            width: parseInt(t.props.containerWidth, 10),
            height: parseInt(t.props.containerHeight, 10)
        }
    }

    function u(e, i) {
        var o = Math.max(e.length, i.length);
        t.times(o, function(t) {
            e[t] || (e[t] = "emptyDivToFillMatrix"), i[t] || (i[t] = "emptyDivToFillMatrix")
        })
    }

    function m(t, e) {
        var i = e;
        return i || (i = !0 === t ? "zoomMode" : "disabled"), i
    }

    function c(i, o) {
        var r = t.defaults({
            href: o.href || "#",
            style: t.assign({
                height: "100%",
                display: "block",
                width: "100%",
                position: "absolute",
                top: "0px",
                left: "0px",
                backgroundColor: "#ffffff",
                filter: "alpha(opacity=0)",
                opacity: "0",
                cursor: o.cursor
            }, s.style.prefix({
                userSelect: "none",
                userDrag: "none",
                userModify: "read-only"
            }))
        }, o);
        return o.href || (r.onClick = function(e) {
            this.props.handleAction({
                type: "comp",
                name: n.constants.ACTION_TYPES.ITEM_CLICKED,
                sourceId: this.props.id,
                pageId: this.props.rootId
            }, function(t, e) {
                return {
                    item: t,
                    timeStamp: s.performance.now(),
                    imageIndex: e,
                    name: n.constants.ACTION_TYPES.ITEM_CLICKED
                }
            }(i, t.get(this.state, "currentIndex"))), e.preventDefault(), e.stopPropagation()
        }.bind(this)), e.DOM.a(r)
    }

    function g(e, i, o, s, n, r, a, l, p) {
        var h, d = {},
            u = "Go to link",
            c = "pointer",
            g = m(i.expandEnabled, i.galleryImageOnClickAction);
        return e.link && (h = s(r, l, o)), i.goToLinkText && (u = i.goToLinkText), "zoomMode" === g ? d = n(l, o, e, a, void 0, p) : h && "goToLink" === g ? d = h : c = "default", t.assign(d, {
            linkData: h,
            goToLinkText: u,
            cursor: c,
            clickAction: g
        }), d
    }

    function f(t) {
        return t ? t.title : ""
    }

    function y(t) {
        return t ? t.description : ""
    }

    function v(e) {
        return {
            currentIndex: t.get(e, "currentIndex", 0),
            isPlaying: "autoplayOn" === t.get(e, "$slideshow", "autoplayOff")
        }
    }
    var I = {
            numCols: 3,
            maxRows: 3,
            margin: 0,
            transition: "seq_crossFade_All",
            transDuration: 1,
            autoplayInterval: 3,
            autoplay: !1,
            showAutoplay: !0,
            showNavigation: !0,
            showCounter: !0
        },
        x = o.compMixins,
        b = o.componentUtils,
        k = s.linkRenderer,
        S = r.matrix.calculations,
        P = l.utils.galleriesHelperFunctions,
        w = b.galleryPagingCalculations,
        C = b.matrixAnimationManipulation;
    return {
        displayName: "PaginatedGridGallery",
        mixins: [x.skinBasedComp, l.mixins.galleryAutoPlayMixin, x.animationsMixin, x.timeoutsMixin, x.compStateMixin(v)],
        propTypes: t.assign({
            compProp: i.Types.Component.compProp.isRequired,
            compData: i.Types.Component.compData.isRequired,
            id: i.Types.Component.id.isRequired,
            skin: i.Types.Component.skin.isRequired,
            style: i.Types.Component.style.isRequired,
            linkRenderInfo: i.Types.Link.linkRenderInfo.isRequired,
            rootNavigationInfo: i.Types.Component.rootNavigationInfo.isRequired,
            isZoomOpened: i.Types.isZoomOpened.isRequired,
            windowTouchEventsAspect: i.Types.SiteAspects.windowTouchEvents.isRequired,
            isMobileView: i.Types.isMobileView,
            isMobileDevice: i.Types.Device.isMobileDevice,
            isTabletDevice: i.Types.Device.isTabletDevice,
            isPlayingAllowed: i.Types.RenderFlags.isPlayingAllowed,
            onAnimationCompleteCallback: e.PropTypes.func,
            createGalleryItem: e.PropTypes.func,
            getItemRef: e.PropTypes.func,
            compActions: i.Types.Component.compActions.isRequired
        }, i.santaTypesUtils.getSantaTypesByDefinition(p)),
        statics: {
            useSantaTypes: !0,
            behaviors: {
                nextSlide: {
                    methodName: "next"
                },
                prevSlide: {
                    methodName: "prev"
                }
            }
        },
        getInitialState: function() {
            return this.props.windowTouchEventsAspect.registerToWindowTouchEvent("touchStart", this), this.isAnimating = !1, t.assign(v(), {
                hoveredImage: null,
                $itemSelection: "idle",
                $mobile: this.props.isMobileDevice || this.props.isTabletDevice ? "mobile" : "notMobile",
                $displayDevice: this.props.isMobileView ? "mobileView" : "desktopView",
                $animationInProcess: null,
                $touchRollOverSupport: "touchRollOut"
            })
        },
        componentWillReceiveProps: function(t) {
            var e = !1,
                i = {
                    $mobile: t.isMobileDevice || t.isTabletDevice ? "mobile" : "notMobile",
                    $displayDevice: t.isMobileView ? "mobileView" : "desktopView"
                };
            if (this.props.compProp.autoplay !== t.compProp.autoplay) {
                var o = t.compProp.autoplay && !this.props.isZoomOpened && this.props.isPlayingAllowed ? "autoplayOn" : "autoplayOff";
                e = !0, i.shouldAutoPlay = t.compProp.autoplay, i.$slideshow = o
            }
            this.setState(i, function() {
                e && (this.updateAutoplayState(), this.handleAction(i.$slideshow))
            }.bind(this))
        },
        componentDidMount: function() {
            this.updateAutoplayState()
        },
        componentWillUnmount: function() {
            this.props.windowTouchEventsAspect.unregisterFromWindowTouchEvent("touchStart", this)
        },
        getButtonVisibility: function(t, e) {
            return !1 === this.props.compProp.showNavigation || this.state.currentIndex === t && this.state.currentIndex === e || this.props.compProp.isHidden ? "hidden" : "visible"
        },
        getSkinProperties: function() {
            var e = t.defaults(this.props.compProp, I),
                i = this.props.compData,
                o = w.getPageItems(i.items, this.state.currentIndex, e.numCols, e.maxRows),
                s = this.state.hoveredImage ? this.state.hoveredImage.props.compData : null,
                n = this.state.hoveredImage ? g(s, e, this.props.rootNavigationInfo, k.renderLink, k.renderImageZoomLink, s.link, i.id, this.props.linkRenderInfo, this.props.id) : {},
                r = w.getNextPageItemIndex(this.state.currentIndex, e.numCols, e.maxRows, i.items.length),
                a = w.getPrevPageItemIndex(this.state.currentIndex, e.numCols, e.maxRows, i.items.length),
                l = w.getPageItems(i.items, r, e.numCols, e.maxRows),
                p = w.getPageItems(i.items, a, e.numCols, e.maxRows),
                h = this.getButtonVisibility(r, a),
                u = !this.props.compProp.isHidden && this.props.compProp.showCounter && o.length > 0 ? "visible" : "hidden",
                m = this.classSet({
                    "show-counter": "hidden" !== h || "hidden" !== u
                });
            return {
                "": {
                    "data-height-diff": P.getSkinHeightDiff(this.props.skin),
                    "data-width-diff": P.getSkinWidthDiff(this.props.skin),
                    onMouseLeave: function(t, e) {
                        this.onRollOut(t, e, !0)
                    }.bind(this),
                    style: {
                        overflow: "hidden"
                    }
                },
                itemsContainer: {
                    children: this.createDisplayedItems(o, l, p, r, a),
                    "data-gallery-id": this.props.id,
                    className: m,
                    style: {
                        position: "relative",
                        overflow: "hidden",
                        width: this.props.style.width - P.getSkinWidthDiff(this.props.skin),
                        height: this.props.style.height - P.getSkinHeightDiff(this.props.skin)
                    }
                },
                buttonPrev: {
                    onClick: function(t) {
                        t && t.stopPropagation(), this.prev()
                    }.bind(this),
                    "data-gallery-id": this.props.id,
                    style: {
                        visibility: h
                    }
                },
                buttonNext: {
                    onClick: function(t) {
                        t && t.stopPropagation(), this.next()
                    }.bind(this),
                    "data-gallery-id": this.props.id,
                    style: {
                        visibility: h
                    }
                },
                counter: {
                    children: w.getCounterText(this.state.currentIndex, e.numCols, e.maxRows, i.items.length),
                    style: {
                        visibility: u
                    },
                    "data-gallery-id": this.props.id
                },
                autoplay: {
                    onClick: this.toggleAutoPlay,
                    "data-gallery-id": this.props.id,
                    style: {
                        cursor: "pointer",
                        visibility: this.shouldShowAutoPlay() ? "visible" : "hidden"
                    }
                },
                rolloverHolder: {
                    style: this.state.hoveredImage ? d(this.state.hoveredImage, this.props.skin) : {
                        visibility: "hidden",
                        cursor: "pointer"
                    },
                    "data-gallery-id": this.props.id,
                    addChildBefore: [c.call(this, s, n), "link"]
                },
                title: {
                    children: this.state.hoveredImage ? f(s) : "",
                    "data-gallery-id": this.props.id
                },
                description: {
                    children: this.state.hoveredImage ? y(s) : "",
                    "data-gallery-id": this.props.id
                },
                link: n.linkData && t.merge(n.linkData, {
                    children: n.goToLinkText,
                    "data-gallery-id": this.props.id,
                    refInParent: "link",
                    style: {
                        display: "goToLink" !== n.clickAction && n.linkData ? "block" : "none"
                    }
                }),
                textWrapper: {
                    "data-gallery-id": this.props.id
                }
            }
        },
        onMouseEnter: function(t) {
            var e = this.refs[t];
            this.state.hoveredImage !== e && this.setState({
                hoveredImage: e,
                $itemSelection: "rollover"
            })
        },
        onRollOut: function(t, e, i) {
            ("IMG" !== t.target.tagName || i) && this.setState({
                hoveredImage: null,
                $itemSelection: "idle"
            })
        },
        onComponentTouchStart: function(t) {
            this.onMouseEnter(t), "touchRollOut" === this.state.$touchRollOverSupport && this.setState({
                $touchRollOverSupport: "touchRollOver"
            })
        },
        onWindowTouchStart: function(t) {
            var e = t.target.getAttribute("data-gallery-id") || t.target.parentNode.getAttribute("data-gallery-id");
            "touchRollOver" === this.state.$touchRollOverSupport && e !== this.props.id && (this.onRollOut({
                target: ""
            }, null, !0), this.setState({
                $touchRollOverSupport: "touchRollOut"
            }))
        },
        next: function(t) {
            this.movePage(!1, t)
        },
        prev: function(t) {
            this.movePage(!0, t)
        },
        movePage: function(e, i) {
            var o = this.props.compProp,
                s = this.props.compData,
                n = e ? w.getPrevPageItemIndex(this.state.currentIndex, o.numCols, o.maxRows, s.items.length) : w.getNextPageItemIndex(this.state.currentIndex, o.numCols, o.maxRows, s.items.length);
            if (this.isAnimating || n === this.state.currentIndex) return this._movePageQueue || (this._movePageQueue = []), void this._movePageQueue.push(e);
            var r, a, l = w.getPageItems(s.items, n, o.numCols, o.maxRows),
                p = w.getPageItems(s.items, this.state.currentIndex, o.numCols, o.maxRows);
            this.props.createGalleryItem ? (r = this.convertDataItemsToRefs(p, this.state.currentIndex), a = this.convertDataItemsToRefs(l, n)) : (r = t.map(p, "id"), a = t.map(l, "id")), l && (this.registerReLayout(), this.setState({
                $animationInProcess: "animationInProcess",
                $itemSelection: "idle"
            }, function() {
                this.performAnimation(r, a, e, n, i)
            }))
        },
        performAnimation: function(e, i, o, s, n) {
            var r = this.props.compProp,
                a = S.getAvailableRowsNumber(r.maxRows, r.numCols, this.props.compData.items.length),
                l = C.getSortedArrayAndStagger(r.transition, e, i, a, r.numCols, this.timingFunctionIndex || 0),
                p = l.transName,
                d = this.props.style.height,
                m = h(r, this.props.style.width, d, a, this.props.skin, p);
            this.timingFunctionIndex = l.timingFunctionIndex + 1;
            var c = "none" === r.transition ? 0 : r.transDuration,
                g = l.stagger,
                f = this.sequence(),
                y = l.sporadicallyRandom && l.sourceNodesArrSorted.length > 1;
            l.sourceNodesArrSorted.length !== l.destNodesArrSorted.length && u(l.sourceNodesArrSorted, l.destNodesArrSorted), t.forEach(l.sourceNodesArrSorted, function(t, e) {
                var i = l.destNodesArrSorted[e],
                    s = {
                        width: m.width,
                        height: m.height,
                        reverse: y ? Math.random() > .5 : !!o
                    },
                    n = g;
                "Shrink" !== p && "CrossFade" !== p || (s.stagger = g, n = 0), f.add({
                    sourceRefs: t,
                    destRefs: i
                }, p, c, 0, s, e * n)
            }), f.onStartAll(function() {
                this.isAnimating = !0
            }.bind(this)).onCompleteAll(function() {
                this.animationCompleteCallback(s, n)
            }.bind(this)).execute()
        },
        animationCompleteCallback: function(e, i) {
            this.isAnimating = !1, this.props.onAnimationCompleteCallback && this.props.onAnimationCompleteCallback(), this.setState({
                currentIndex: e,
                $animationInProcess: null
            }, function() {
                this.updateAutoplayState(), t.isFunction(i) && i()
            }.bind(this)), this._movePageQueue && this._movePageQueue.length > 0 && setTimeout(function() {
                this.movePage(this._movePageQueue.shift())
            }.bind(this), 100)
        },
        createDisplayedItems: function(e, i, o, s, n) {
            var r = this.props.compProp,
                a = this.props.compData,
                l = parseFloat(this.props.style.width),
                p = S.getItemWidth(r.margin, r.numCols, l, P.getSkinWidthDiff(this.props.skin)),
                h = S.getAvailableRowsNumber(r.maxRows, r.numCols, a.items.length),
                d = S.getItemHeight(r.margin, this.props.style.height, h, P.getSkinHeightDiff(this.props.skin)),
                u = [],
                m = [],
                c = t.map(e, function(t, i) {
                    return this.createGalleryItem(t, i, p, d, this.state.currentIndex, e.length, "curr")
                }.bind(this));
            return s !== this.state.currentIndex && (u = t.map(i, function(t, e) {
                return this.createGalleryItem(t, e, p, d, s, i.length, "next", {
                    visibility: "hidden"
                })
            }.bind(this))), n !== s && n !== this.state.currentIndex && (m = t.map(o, function(t, e) {
                return this.createGalleryItem(t, e, p, d, n, o.length, "prev", {
                    visibility: "hidden"
                })
            }.bind(this))), u.concat(m).concat(c)
        },
        createGalleryItem: function(t, e, i, o, s, n, r, a) {
            return this.props.createGalleryItem ? this.props.createGalleryItem(this.props.id, t, e, s, n, a, this.classSet) : this.createImageItem(t, e, i, o, s, r, a)
        },
        convertDataItemsToRefs: function(t, e) {
            for (var i = [], o = 0; o < t.length; o++) {
                var s = this.props.getItemRef ? this.props.getItemRef(this.props.id, e, o) : this.getImageItemRef(e, o);
                i.push(s)
            }
            return i
        },
        getImageItemRef: function(t, e) {
            return this.props.id + t + e
        },
        createImageItem: function(e, i, o, s, n, r, l) {
            var p = S.getItemPosition(i, o, s, this.props.compProp.margin, this.props.compProp.numCols),
                h = S.getImageStyle(s, o, e.height, e.width);
            return this.createChildComponent(e, "core.components.Image", "img", {
                id: this.props.id + e.id,
                ref: e.id,
                key: e.id,
                imageData: e,
                containerWidth: Math.round(o),
                containerHeight: Math.round(s),
                displayMode: a.fittingTypes.SCALE_TO_FILL,
                imgStyle: h,
                "data-gallery-id": this.props.id,
                "data-page-desc": r,
                "data-query": e.id,
                "data-image-index": n + i,
                onMouseEnter: this.onMouseEnter.bind(this, e.id),
                onTouchStart: this.onComponentTouchStart.bind(this, e.id),
                style: t.merge({
                    left: p.left,
                    top: p.top,
                    position: "absolute",
                    overflow: "hidden",
                    transform: "none",
                    clip: "auto"
                }, l)
            })
        }
    }
});
//# sourceMappingURL=paginatedGridGallery.min.js.map
"use strict";
define("fileUploader/components/fileUploader", ["santaProps", "lodash", "reactDOM", "core", "textCommon", "siteUtils"], function(e, t, i, o, s, n) {
    function a(e) {
        return t.assign(o.compMixins.validatableWithSyncMixin.getPublicState(e), {
            value: t.get(e, ["value"], []),
            uploadStatus: t.get(e, "uploadStatus", c.NOT_STARTED),
            serverMessage: t.get(e, "serverMessage", "")
        })
    }

    function p(e) {
        var i = t.get(e, "valid"),
            o = t.get(e, "fileNotUploaded");
        return !i && !o
    }
    var r = o.compMixins,
        l = e.Types,
        d = n.fileUploadManager,
        c = {
            NOT_STARTED: "NOT_STARTED",
            STARTED: "STARTED",
            FAILED: "FAILED",
            DONE: "DONE"
        };
    return {
        displayName: "FileUploader",
        mixins: [r.skinBasedComp, s.textScaleMixin, o.compMixins.inputFocusMixin, o.compMixins.validatableWithSyncMixin.validatableWithSync, o.compMixins.compStateMixin(a)],
        statics: {
            useSantaTypes: !0,
            behaviors: t.assign({}, o.compMixins.inputFocusMixin.INPUT_FOCUS_BEHAVIORS, o.compMixins.validatableWithSyncMixin.VALIDATABLE_WITH_SYNC_BEHAVIORS)
        },
        propTypes: t.assign({
            compData: e.Types.Component.compData.isRequired,
            compProp: e.Types.Component.compProp.isRequired,
            siteMediaToken: l.RendererModel.siteMediaToken.isRequired,
            windowKeyboardEvent: e.Types.SiteAspects.windowKeyboardEvent.isRequired,
            getMediaFullStaticUrl: e.Types.ServiceTopology.getMediaFullStaticUrl,
            shouldResetComponent: e.Types.RenderFlags.shouldResetComponent.isRequired
        }),
        getInitialState: function() {
            return a()
        },
        isUploading: function() {
            return this.state.uploadStatus === c.STARTED
        },
        componentDidMount: function() {
            this.props.windowKeyboardEvent.registerToKeyDownWithFocus(this, this.refs.chooseFileButton)
        },
        componentWillReceiveProps: function(e) {
            e.shouldResetComponent && this.props.shouldResetComponent !== e.shouldResetComponent && (this.hideValidityIndication(), this.removeFile())
        },
        onKeyDown: function(e) {
            var i = [13, 32];
            if (!this.props.compProp.isDisabled && t.includes(i, e.keyCode)) {
                var o = t.includes(e.target.className, "chooseFileButton"),
                    s = t.includes(e.target.classList[0], "uploadName");
                o ? (this.refs.fileInput.click(), this.refs.chooseFileButton.blur()) : s && this.removeFile()
            }
        },
        focus: function() {
            this.refs.chooseFileButton.focus()
        },
        blur: function() {
            this.refs.chooseFileButton.blur()
        },
        createFileNodes: function(e) {
            var i = this.props.compProp.showPlaceholder,
                o = this.props.compProp.filesAlignment,
                s = this.props.compData.placeholderLabel,
                n = t.cloneDeep(this.state.value),
                a = {
                    isPlaceholder: !!t.isEmpty(n) && i,
                    alignment: o,
                    previewState: e,
                    errorState: this.hasErrorIndication() && this.shouldShowValidityIndication(),
                    removeFunction: this.removeFile,
                    scale: t.get(this.props, "structure.layout.scale"),
                    uploading: this.isUploading()
                };
            return t.isEmpty(n) && (t.isUndefined(e) ? (s = "" === s ? " " : s, n.push({
                name: s
            }), i && " " !== s || (a.hidePlaceholder = !0)) : (n.push({
                name: "Example.txt"
            }), a.isPlaceholder = !1)), t.map(n, function(e, t) {
                return this.createChildComponent({
                    id: "uploadName" + t,
                    fileName: e.name
                }, "wysiwyg.viewer.components.inputs.uploadName", "uploadName", a)
            }.bind(this))
        },
        removeFile: function() {
            this.isUploading() || this.setState({
                value: [],
                uploadStatus: c.NOT_STARTED
            }, function() {
                i.findDOMNode(this.refs.fileInput).value = "", this.handleAction(n.constants.ACTION_TYPES.CHANGE)
            }.bind(this))
        },
        getUploadCompleteCB: function(e) {
            return function(t) {
                var i = t[0];
                "Image" === this.props.compProp.filesType && (i.uri = i.file_name, i.title = i.file_name), e && e(i, null), this.setState({
                    uploadStatus: c.DONE
                }, function() {
                    this.handleAction(n.constants.ACTION_TYPES.VALIDATE)
                })
            }.bind(this)
        },
        getUploadFailedCB: function(e) {
            return function(t) {
                var i = {
                    errorCode: t.error_code,
                    errorDescription: t.error_description
                };
                e && e(null, i), this.setState({
                    uploadStatus: c.FAILED,
                    serverMessage: i.errorDescription
                }, function() {
                    this.handleAction(n.constants.ACTION_TYPES.VALIDATE)
                })
            }.bind(this)
        },
        isReadyToUpload: function() {
            return !this.isUploading() && !t.isEmpty(this.state.value) && !p(this.getValidity())
        },
        uploadFiles: function(e) {
            if (this.isReadyToUpload()) {
                var i = this.props.siteMediaToken,
                    o = this.props.compProp.filesType,
                    s = this.getUploadCompleteCB(e),
                    n = this.getUploadFailedCB(e);
                this.setState({
                    uploadStatus: c.STARTED
                }, function() {
                    t.forEach(this.refs.fileInput.files, function(e) {
                        d.uploadFile(e, i, o, s, n)
                    })
                })
            }
        },
        onFileSelectionChange: function() {
            if (this.refs.fileInput.files.length > 0) {
                var e = t.map(this.refs.fileInput.files, function(e) {
                    return {
                        name: e.name,
                        size: e.size
                    }
                });
                this.setState({
                    value: e,
                    uploadStatus: c.NOT_STARTED
                }, function() {
                    this.handleAction(n.constants.ACTION_TYPES.CHANGE)
                })
            }
        },
        getAcceptableFileTypes: function() {
            switch (this.props.compProp.filesType) {
                case "Image":
                    return ".jpeg,.png,.jpg";
                case "Document":
                    return ".pdf,.doc,.docx,.ppt,.pptx,.xls,.xlsx,.odp,.odt,.epub"
            }
        },
        handleButtonFocus: function(e) {
            this.handleAction(n.constants.ACTION_TYPES.FOCUS, e)
        },
        handleButtonBlur: function(e) {
            this.handleAction(n.constants.ACTION_TYPES.BLUR, e)
        },
        hasErrorIndication: function() {
            if (this.isValid()) return !1;
            var e = this.getValidity();
            return t.some(t.omit(e, "fileNotUploaded", "valid")) || this.state.uploadStatus === c.FAILED
        },
        getSkinProperties: function() {
            var e = this.props.compData,
                t = this.props.compProp,
                i = {
                    "no-label": "" === e.buttonLabel
                };
            i[t.buttonAlignment] = !0;
            var o = this.getComponentPreviewState() || this.props.previewState,
                s = !!this.props.compProp.isDisabled || this.isUploading();
            return {
                "": {},
                chooseFileButton: {
                    className: this.classSet(i),
                    onClick: function() {
                        s || (this.refs.fileInput.click(), this.refs.chooseFileButton.blur())
                    }.bind(this),
                    onFocus: s ? null : this.handleButtonFocus,
                    onBlur: s ? null : this.handleButtonBlur,
                    "data-preview": o,
                    "data-disabled": s,
                    "data-error": this.hasErrorIndication() && this.shouldShowValidityIndication()
                },
                buttonLabel: {
                    children: [e.buttonLabel],
                    style: this.getFontSize("btn_fnt")
                },
                fileInput: {
                    onChange: this.onFileSelectionChange,
                    accept: this.getAcceptableFileTypes()
                },
                files: {
                    children: this.createFileNodes(o),
                    "data-preview": o
                }
            }
        }
    }
}), define("fileUploader/components/uploadName", ["santaProps", "react", "lodash", "core", "textCommon"], function(e, t, i, o, s) {
    return {
        displayName: "UploadName",
        mixins: [o.compMixins.skinBasedComp, s.textScaleMixin],
        statics: {
            useSantaTypes: !0
        },
        propTypes: i.assign({
            compData: e.Types.Component.compData.isRequired,
            compProp: e.Types.Component.compProp.isRequired,
            alignment: t.PropTypes.string.isRequired,
            removeFunction: t.PropTypes.func.isRequired,
            isPlaceholder: t.PropTypes.bool.isRequired,
            scale: t.PropTypes.number.isRequired,
            previewState: t.PropTypes.string,
            errorState: t.PropTypes.bool,
            uploading: t.PropTypes.bool,
            windowKeyboardEvent: e.Types.SiteAspects.windowKeyboardEvent.isRequired
        }),
        componentDidMount: function() {
            var e = this.props.id.split("uploadName")[0];
            this.props.windowKeyboardEvent.registerToKeyDownWithFocus({
                props: {
                    id: e
                }
            }, this.refs["x-icon"])
        },
        getSkinProperties: function() {
            var e = this.props.compData,
                t = {};
            t["align-" + this.props.alignment] = !0, t["hide-placeholder"] = this.props.hidePlaceholder;
            var i = !!this.props.compProp.isDisabled || this.props.uploading,
                o = this.getComponentPreviewState() || this.props.previewState,
                s = this.props.errorState;
            return {
                "": {
                    className: this.classSet(t),
                    "data-preview": o,
                    "data-error": s
                },
                "x-icon": {
                    style: this.props.isPlaceholder ? {
                        display: "none"
                    } : {},
                    onClick: function() {
                        this.props.removeFunction && !this.props.uploading && this.props.removeFunction(e.fileName)
                    }.bind(this),
                    "data-preview": o,
                    "data-disabled": i
                },
                "file-name": {
                    className: this.classSet({
                        "file-name-placeholder": this.props.isPlaceholder
                    }),
                    children: [e.fileName],
                    "data-preview": o,
                    "data-disabled": i,
                    style: this.getFontSize("file_fnt", this.props.scale)
                }
            }
        }
    }
}), define("fileUploader", ["fileUploader/components/fileUploader", "fileUploader/components/uploadName"], function(e, t) {
    return {
        fileUploader: e,
        uploadName: t
    }
});
//# sourceMappingURL=fileUploader.min.js.map